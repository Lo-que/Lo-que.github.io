{"meta":{"title":"Blog","subtitle":"Blog","description":"qudongqi's personal blog","author":"屈东奇","url":"http://lo-que.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"ts学习小结","date":"2021-09-25T10:23:38.946Z","updated":"2021-11-24T06:41:34.094Z","comments":true,"path":"2021/09/25/ts学习小结/","link":"","permalink":"http://lo-que.github.io/2021/09/25/ts%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/","excerpt":"","text":"TS学习小结内置实用类型Partial&lt;Type&gt;可以将原本必要需要类型变为可选属性的类型 interface IState &#123; title: string; description: string; &#125; function test(state: IState, newState: Partial&lt;IState&gt;) &#123; return &#123;...state, ...newState&#125; &#125; const state:IState = &#123; title: &#39;标题&#39;, description: &#39;这是描述&#39; &#125; const newState: Partial&lt;IState&gt; = &#123; title: &#39;只有标题&#39; &#125; // ===&gt; 等价于 interface IState &#123; title?: string; description?: string; &#125; Required&lt;Type&gt;Required 和 Partial 相反，把之前的可选类型全部变为必要需要类型 interface Props &#123; a?: number; b?: string; &#125; const obj: Props = &#123; a: 5 &#125;; const obj2: Required&lt;Props&gt; = &#123; a: 5 &#125;; // 类型 &quot;&#123; a: number; &#125;&quot; 中缺少属性 &quot;b&quot;，但类型 &quot;Required&lt;Props&gt;&quot; 中需要该属性 Readonly&lt;Type&gt;构建具有只读的类型，无法修改 interface ITest &#123; id: number &#125; const test: Readonly&lt;ITest&gt; = &#123; id: 4396 &#125; test.id = 443 // 无法分配到 &quot;id&quot; ，因为它是只读属性 Record&lt;Keys,Type&gt;可以约束对象的 key, props 的类型 type IBook = &#39;language&#39; | &#39;math&#39; interface IProp &#123; price: number; page_number: number; publish?: string &#125; const math: Record&lt;IBook, IProp&gt; = &#123; language: &#123; price: 29, page_number: 200 &#125;, math: &#123; price: 49, page_number: 100 &#125; &#125; math.language Pick&lt;Type, Keys&gt;可以取出选择的类型声明中的几个字段生成一个新的类型 interface IBook &#123; title: string; description: string; price: number; &#125; type IBuyBook = Pick&lt;IBook, &quot;title&quot; | &quot;price&quot;&gt;; const buy: IBuyBook = &#123; title:&#39;typescript&#39;, price: 55 &#125; buy Omit&lt;Type, Keys&gt;与Pick相反 可以复制原有类型， 并且移出掉不需要的属性生成新的类型 interface IBook &#123; title: string; description: string; price: number; publish: string; author: string; &#125; type IPreview = Omit&lt;IBook, &quot;author&quot; | &quot;price&quot;&gt; type IPrice = Omit&lt;IBook, &quot;author&quot; | &quot;description&quot; &gt; const language: IPreview = &#123; title: &#39;language&#39;, description: &#39;语文&#39;, publish: &#39;china&#39; &#125; const math: IPrice = &#123; title: &#39;language&#39;, price: 23, publish: &#39;china&#39; &#125; Exclude&lt;Type, ExcludedUnion&gt;通过排除特定的类型， 生成新的一个类型 type IPrice = Exclude&lt; number | string | (()=&gt; number ), Function&gt; // type IPrice = number | string type IName = Exclude&lt; &#39;小李&#39; | &#39;小张&#39; | (()=&gt; string), Function&gt; // type IName = &#39;小李&#39; | &#39;小张&#39; Extract&lt;Type, Union&gt;与 Exclude 类型相反，通过匹配两者之间的交集生成一个新的交集类型 type IPrice = Extract&lt; number | string | (()=&gt; number ), string | boolean&gt; // type IPrice = string type IName = Extract&lt; &#39;小李&#39; | &#39;小张&#39; | (()=&gt; string), &#39;小张&#39;| &#39;小李&#39; | boolean&gt; // type IName = &#39;小张&#39;| &#39;小李&#39; NonNullable&lt;Type&gt;排除无用值属性，生成一个新的类型。比如 undefined,null type IPrice = NonNullable&lt; number | string | undefined | null&gt; // type IPrice = number | string Parameters&lt;Type&gt;通过函数参数构建的一个数组类型, 注意: string, boolean, Function 不满足约束要求 declare function f1(arg: &#123; a: number; b: string &#125;): void; type T0 = Parameters&lt;() =&gt; string&gt;; // type T0 = [] type T1 = Parameters&lt;(s: string) =&gt; string&gt;; // type T1 = [s: string] type T2 = Parameters&lt; &lt;K&gt;(args: K) =&gt; K&gt;; // type T2 = [args: unkonw] type T3 = Parameters&lt; typeof f1&gt; // type T3 = [args: &#123;a: number, b: string&#125;] type T4 = Parameters&lt;any&gt;; // type T4 = unknow[] type T5 = Parameters&lt;never&gt;; // type T5 = never ConstructorParameters&lt;Type&gt;通过特殊的构建器函数构造数组类型, 不支持 Function 类型 type T0 = ConstructorParameters&lt;FunctionConstructor&gt; // type T0 = string[] type T1 = ConstructorParameters&lt;ErrorConstructor&gt; // type T1 = [message?: string] type T2 = ConstructorParameters&lt;ObjectConstructor&gt; // | NumberConstructor | BooleanConstructor | StringConstructor // type T2 = [value?: any] type T3 = ConstructorParameters&lt;RegExpConstructor&gt; // type T3 = [pattern: string | RegExp, flags?: string] type T4 = ConstructorParameters&lt;any&gt; // type T4 = unknown[] InstanceType&lt;Type&gt;由构造函数实例构成的类型, 不支持 string, number, boolean, Function, Symbo class K &#123; constructor()&#123;&#125; x = 0; y = 0; &#125; type T0 = InstanceType&lt;typeof K&gt; // type T0 = K ReturnType&lt;Type&gt;构建函数返回值组成的类型 declare function fn(): &#123; a: number; b: string, c: Function &#125;; type T0 = ReturnType&lt;() =&gt; string&gt;; // type T0 = string type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // type T1 = void type T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // type T2 = unknown type T3 = ReturnType&lt;&lt;T extends U, U extends string[]&gt;() =&gt; T&gt;; // type T3 = string[] type T4 = ReturnType&lt;typeof fn&gt; // type T4 = &#123; // a: number; // b: string; // c: Function; // &#125; 参考链接TS 官网 utility-types 特殊操作符keyof可以获取某个类型的所有 key(键), 通过 key 的类型来生成一个新的联合类型 type Point = &#123; x: number; y: number &#125;; type P = keyof Point; type Point1 = &#123; [x: number]: number, [y: string]: number &#125;; type P1 = keyof Point1; // type P1 = number | string type Point2 = &#123; x: number, [y: string]: number &#125;; type P2 = keyof Point1; // type P2 = number | string // 获取属性用法 function getProp&lt;T extends object, K extends keyof T&gt;(obj:T, key:K)&#123; return obj[key]; &#125; 参考链接 TS keyof typeoftypeof 本来就是 js 中的关键字，不过这里可以扩展一些特别的方法,可以通过 typeof 中推断的类型创建类型 function fn() &#123; return &#123; a: 1, b: &#39;name&#39; &#125; &#125; let _name = &#39;小李&#39; type T0 = typeof _name; // type T0 = string type T1 = ReturnType&lt;typeof fn&gt; // type T1 = &#123; // a: number; // b: string; // &#125; 参考链接 TS typeof in keyof迭代 O 对象的 key，并且判断是否属于 O, 生成一个新的类型 type K = &#123; x: string | number, y: string | number &#125; type Point&lt;O&gt; = &#123; [K in keyof O]: O[K] &#125; var b: Point&lt;K&gt; = &#123; x: 2, y: &#39;32px&#39;, z: false // z error z error 不能将类型“&#123; x: number; y: string; z: boolean; &#125;”分配给类型“Point&lt;K&gt;”。对象文字可以只指定已知属性，并且“z”不在类型“Point&lt;K&gt;”中。 &#125; 参考链接 TS Creating Types from Types","categories":[],"tags":[]},{"title":"http协议那些事儿","slug":"http协议那些事儿","date":"2021-08-11T03:40:21.000Z","updated":"2021-11-24T07:41:42.873Z","comments":true,"path":"2021/08/11/http协议那些事儿/","link":"","permalink":"http://lo-que.github.io/2021/08/11/http%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","excerpt":"","text":"Http协议那些事儿作为一个 web 开发，HTTP 几乎是天天要打交道的东西，但我发现大部分人对 HTTP 只是浅尝辄止。这篇文章就是为了帮助大家也帮助我树立完整的 HTTP 知识体系，提升自己作为一个 web 开发的专业素养。 本文可能涉及到的知识点。 当我们输入网址后发生了什么 HTTP协议详解 Cookie与session HTTP缓存机制 HTTPS 协议分析 HTTP2 协议分析 了解HTTP3 在开始正文之前，我们需要先搞定一个知识点。 什么是http请求？ 下图是http请求模型。由客户端发起请求，服务器响应请求。 所以，我们这里需要记住的是，发起请求的是客户端，响应请求的是服务器。 有一个最常见的面试题，当我们输入网址后发生了什么？ 处理流程 输入网址并回车 解析域名 浏览器发送HTTP请求 服务器处理请求 服务器返回HTML响应 浏览器处理HTML页面 继续请求其他资源 上图是一个简单的流程图 用户打算访问google.com 先经过防火墙 代理服务器 家用路由器 软件 查找域名对应服务器 域名的解析需要用到一系列的服务器，而不是简单的一个服务器。比如：用户想要解析 www.google.com: 在本机上输入https://www.google.com 2 号服务器是用户在自己电脑上填写的 DNS 地址，由于域名和 ip 地址的对照表非常庞大，因此 2 号服务器会进行分层管理。2 号服务器进行域名解析是会先从缓存中进行查找，如果一个域名被频繁访问，通常会被保存到缓存中。如果 DNS 这没有对应的域名-IP 缓存，那么就需要向根服务器(Root Server)发起请求。 根服务器负责维护全球的域名-IP 地址解析。根服务器会检查域名后缀(比如.com)，根据不同的后缀，交给不同的 TLD 服务器处理。获取到后缀后，返回对应的 TLD 服务器的 ip 地址(com = 1.1.1.1)。 DNS 拿到 TLD 服务器的 IP 地址后，继续向 TLD 服务器进行询问。TLD 服务器只返回顶级域名对应的 IP(https://google.com = 2222)，交给顶级域名对应的 Name Server 处理。 DNS 服务器获取到顶级域名的 IP 后，继续向 Name Server 进行询问。Name Server 返回具体的域名对应的 IP 地址。 DNS 服务器获取到具体的域名对应的 IP 后，会先进行缓存，避免下次请求时继续多次询问。 虽然看起来是一条直线。但实际上是经过一跳有一跳路由。可通过traceroute查看 就像是反向代理服务器，找到真正的ip地址对应的服务器 什么是HTTP协议 HTTP是超文本传输协议，从www浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTTP协议是由客户机到服务器的请求(Request)和从服务器到客户机的响应(response)进行约束和规范。 Q&amp;A 为什么说http是一个无状态协议？ 因为它的每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更。即使在 HTTP/1.1 上，同一个链接允许传输多个HTTP请求的情况下，如果第一个请求出错了，后面的请求一般也能够继续处理(当然，如果导致协议解析失败、封片错误之类的自然是要除外的)。可以看出，这种协议的结构是要比有状态的协议更简单的，一般来说实现起来也更简单，不需要使用状态机，一个循环就行了 HTTP协议是无状态协议，这句话本身到底对不对？ 实际上，并不全对。HTTP/1.1中有一个Expect：100-Continue的功能，它是这么工作的： 在发送大量数据的时候，考虑到服务端有可能直接拒收数据，客户端发起请求头并附带Expect：100-Continue的HTTP头，不发送请求体，先等待服务器响应 服务器收到Expect：100-Continue的请求，如果允许上传，发送100-Continue的HTTP响应(同一个请求可以有任意个1xx的响应，均不是最后的Response，只起到提示性作用)；如果不允许，例如不允许上传数据，或者数据大小超出限制，直接返回4xx/5xx的错误 客户端收到100-Continue的响应之后，继续上传数据 可以看出，这实际上很明显是一个有状态协议的套路，他需要先进行一次五首，然后再真正发送数据。不过，HTTP协议也规定，如果服务端不进行100-Continue的响应，建议客户端在等待较短的时间之后仍然上传数据，以达成与不支持Expect：100-Continue功能的服务器的兼容，这样可以算是”能有状态则有状态，否则会到无状态的路上”，这样说HTTP 1.x是无状态的协议也是没错的。 至于 HTTP/2，它应该算是一个有状态的协议了(有握手和GOAWAY消息，有类似于TCP的流控)，所以以后说”HTTP是无状态的协议”就不太对了，最好说”HTTP 1.x是无状态的协议” HTTP1.0 和 HTTP1.1 的一些区别 1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在： 缓存处理： 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since, Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag, If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用： HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理： 在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host 头处理： 在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。 长连接： HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，其中长连接也就是对应在 HTTP1.1 中的 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。 了解TCP/IP协议栈 左边是 ISO/OSI标准协议，右图是事实协议， ISO/OSI 标准协议 是对事实协议的一个补充，最初设计的不完整. 更多详细流程，参考 TCP 协议那些事儿 （还没来得及写，(笑 ） 应用层 为用户提供功能所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等 传输层 为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性 该层定义了两个主要的协议：传输控制协议(TCP)和用户数据报协议(UDP) 网络层 主要解决主机到主机的通信问题。IP协议是网际互联网层最重要的协议。 网络接口层 负责监视数据在主机和网络之间的交换 在TCP/IP协议栈中的位置 目前普遍应用版本HTTP 1.1 正在逐步向HTTP 2迁移 HTTP默认端口号为80 HTTPS默认端口号为443 HTTP的工作过程 一次HTTP操作称为一个事务，其工作过程可分为四步: 首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为:统一资源标识符(URI)、协议版本号， 后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功 或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 请求与响应HTTP请求组成：请求行、消息报头、请求正文 HTTP响应组成：状态行、消息报头、响应正文 请求行组成：以一个方法符号开头，后面跟着请求的URI和协议的版本 状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的文本描述。 请求: 响应: 请求方法概述GET： 请求获取Request-URI所标识的资源 POST： 在Request-URI所标识的资源后附加新的数据 HEAD： 请求获取由Request-URI所标识的资源的响应消息报头 PUT： 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE： 请求服务器删除Request-URI所标识的资源 TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求 HTTP状态码状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 1xx ​ 101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。 2xx ​ 200 OK是见得最多的成功状态码。通常在响应体中放有数据。 ​ 204 No Content含义与 200 相同，但响应头后没有 body 数据。 ​ 206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。 3xx ​ 301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。 ​ 比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访 问重定向的那个地址。 ​ 而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。 ​ 304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存 4xx ​ 400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。 ​ 403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。 ​ 404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。 ​ 405 Method Not Allowed: 请求方法不被服务器端允许。 ​ 406 Not Acceptable: 资源无法满足客户端的条件。 ​ 408 Request Timeout: 服务器等待了太长时间。 ​ 409 Conflict: 多个请求发生了冲突。 ​ 413 Request Entity Too Large: 请求体的数据过大。 ​ 414 Request-URI Too Long: 请求行里的 URI 太大。 ​ 429 Too Many Request: 客户端发送的请求过多。 ​ 431 Request Header Fields Too Large请求头的字段内容太大。 5xx ​ 500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。 ​ 501 Not Implemented: 表示客户端请求的功能还不支持。 ​ 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。 ​ 503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。 常用的请求报头Accept 请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，Accept：text/ htmlAccept-Charset 请求报头域用于指定客户端接受的字符集。Accept-Encoding：Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。 Accept-Language 请求报头域类似于Accept，但是它是用于指定一种自然语言 Authorization 请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，发 送请求时，该报头域是必需的。 User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 常用的响应报头Location 响应报头域用于重定向接受者到一个新的位置。Location响应 报头域常用在更换域名的时候。 Server 响应报头域包含了服务器用来处理请求的软件信息。与User\u0002Agent请求报头域是相对应的。 WWW-Authenticate 响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。 常用的实体报头Content-Encoding 实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。 Content-Language 实体报头域描述了资源所用的自然语言。 Content-Length 实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Content-Type 实体报头域用语指明发送给接收者的实体正文的媒体类型。 Last-Modified 实体报头域用于指示资源的最后修改日期和时间。 Expires 实体报头域给出响应过期的日期和时间。 cookies与session Cookies是保存在客户端的小段文本，随客户端点每一个请求发送该url下的所有cookies到服务器端。 Session则保存在服务器端，通过唯一的值sessionID来区别每一个用户。SessionID随每个连接请求发送到服务器，服务器根据sessionID来识别客户端，再通过session 的key获取session值 Cookie使用与Cookie相关的HTTP扩展头 Cookie：客户端将服务器设置的Cookie返回到服务器 Set-Cookie：服务器向客户端设置Cookie 服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持 Session的使用 使用Cookie来实现 使用URL回显来实现 HTTP缓存机制缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。 缓存的优点： 减少相应延迟 减少网络带宽消耗 浏览器缓存机制没有缓存 有缓存 两种缓存策略浏览器缓存主要有两类 强制缓存 协商缓存 HTTP 1.0: 基于Pragma &amp; Expires的缓存实现 Pragma Expire 这三者的优先级顺序为:Pragma -&gt; Cache-Control -&gt; Expires HTTP 1.1 Cache-Control:相对过期时间 强缓存 利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间 普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上Cache-Control:no-cache和Pragma:no-cache Expires （http 1.0） Cache-Control 协商缓存 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 Etag 和 If-None-Match Last-Modify / If-Modify-Since 缓存优先级Cache-Control &gt; Expires &gt; Etag &gt; Last-modify Request/Response Headers Web页面设计中，建少HTTP请求可以提高页面响应速度。浏览器在第一次访问页面时下载的资源会缓存起来，第二次访问时会判断在缓存中是否已有该资源并且有没有更新过，如果已有该资源且没有更新过，则去缓存去取，这样减少了下载资源的时间。原理上是通过HTTP Rquest Header中的 if-modified-since 和Response Headers中的last-modified来实现（还有一对组合If-None-Match和Etag，类似），HTTP请求把if-modified-sincede 时间传给服务端，服务端把last-modified时间与之对比，如果相同，则意味着文件没有改动，则返回304，浏览器则从缓存中获取资源，无需下载。 协商缓存 last-modified / if-modified-since Response Headers last-modified: Wed, 16 May 2020 12:57:16 GMT Request Headers if-modified-since: Wed, 16 May 2020 12:55:38 GMT 原理： 服务器端返回资源时，如果头部带上了 last-modified，那么资源下次请求时就会把值加⼊到请求头 if-modified-since中，服务器可以对⽐这个值，确定资源是否发⽣变化，如果没有发⽣变化，则返回 304 协商缓存 etag / if-none-match Response Headers etag: “D5FC8B85A045FF720547BC36FC872550” Request Headers if-none-match: “D5FC8B85A045FF720547BC36FC872550” 原理： 服务器端返回资源时，如果头部带上了 etag，那么资源下次请求时就会把值加⼊到请求头 if-none-match 中，服务器可以对⽐这个值，确定资源是否发⽣变化，如果没有发⽣变化，则返回 304 Response Headers 强缓存 Expires expires: Thu, 16 May 2020 03:05:59 GMT 原理： 在 http 头中设置⼀个过期时间，在这个过期时间之前，浏览器的请求都不会发出，⽽是⾃动从缓存中读取⽂件，除⾮缓存被清空，或者强制刷新。缺陷在于，服务器时间和⽤户端时间可能存在不⼀致，所以 HTTP/1.1 加⼊了 cache-control 头来改进这个问题 强缓存 cache-control 原理： 设置过期的时间⻓度（秒），在这个时间范围内，浏览器请求都会直接读缓存。当 expires 和 cache-control 都存在时，cache-control 的优先级更⾼ 小结 expires也是需要在服务端配置（具体配置也根据服务器而定），expires添加的是该资源过期的日期，浏览器会根据该过期日期与客户端时间对比，如果过期时间还没到，则会去缓存中读取该资源，如果已经到期了，则浏览器判断为该资源已经不新鲜要重新从服务端获取。通过这种方式，可以实现直接从浏览器缓存中读取，而不需要去服务端判断是否已经缓存，避免了这次http请求。值得注意的是expires时间可能存在客户端时间跟服务端时间不一致的问题。所以，建议expires结合Cache-Control一起使用，大型网站中一起使用的情况比较多见 接下来我们继续。 相信大家也发现了，我们的时间轴刚刚走到HTTPS协议，先储备两个知识点，密钥交换和数字证书 https 加密方式涉及到密钥交换 一般的证书都是三级;第一级是根证书签发机构(CA), 第二级是二级签发机构,到最后才是证书; 根证书是内置到操作系统和浏览器里面的 密码学入门 密码学的处理对象是数字和字符串。 散列是一种数据一旦转换为其他形式将永远无法恢复的加密技术。 加密 对称加密(AES、DES、3DES) 非对称加密(RSA) 加密 解密 密钥交换算法Diffie-Hellman 算法是一种著名的密钥协商算法，这种算法可以使得信息交换的双方通过公开的非安全的网络协商生成安全的共享密钥。 Alice与Bob确定两个大素数n和g，这两个数不用保密 Alice选择另一个大随机数x，并计算A如下：A=gx mod n Alice将A发给Bob Bob选择另一个大随机数y，并计算B如下：B=gy mod n Bob将B发给Alice 计算秘密密钥K1如下：K1=Bx mod n 计算秘密密钥K2如下：K2=Ay mod n K1=K2，因此Alice和Bob可以用其进行加解密 证书签发机构(CA)通过CA发放的证书完成密钥的交换，实际上是利用非对称的加密算法完成数据加密密钥 的安全交换，然后再利用数据加密密钥完成数据的安全交换。 数字证书:数字证书是互联网通信中标识双方身份信息的数字文件，由CA签发。 CA:CA(certification authority)是数字证书的签发机构。作为权威机构，其审核申请 者身份后签发数字证书，这样我们只需要校验数字证书即可确定对方的真实身份。 CA的工作流程 服务器 example.com将从CA请求TLS证书，例如 Digicert。 Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称， 服务器的公钥等。 Digicert将创建数据(证书)的哈希值，并使用自己的私钥对其进行加密。 浏览器和操作系统自带Digicert等权威机构的公钥。 当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中 指定的散列算法生成数据(证书)的散列，如果两个哈希值匹配，则签名验证成 功并且证书是可信的。 现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。 在这里，我们可以将Digicert称为 Root CA. 在这里，我们可以将Digicert称为 Root CA. 浏览器如何验证服务器证书的有效性 证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工作，即Digicert，Geotrust，Comodo等。如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引入了中间CA(intermediate CA)的概念。 服务器使用中级证书颁发机构的签名，因此，在与浏览器通信时，服务器将共享两个证书: 包含服务器的公钥，即实际的服务器证书; 由 Root CA 颁发的 intermediate CA 证书。 在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA的 公钥来验证中间证书的数字签名，如果成功，浏览器现在可以信任中 间证书及其公钥。现在使用此公钥，浏览器将验证原始服务器证书的 签名，该组织可以注册为intermediate CA，以便为其域签署证书。 Q&amp;A: 1.浏览器拿到数字证书后，如何来对证书进行认证呢？ 首先，会读取证书中的明文内容。CA 进行数字证书的签名时会保存一个 Hash 函数，来这个函数来计算明文内容得到信息A，然后用公钥解密明文内容得到信息B，两份信息做比对，一致则表示认证合法。 当然有时候对于浏览器而言，它不知道哪些 CA 是值得信任的，因此会继续查找 CA 的上级 CA，以同样的信息比对方式验证上级 CA 的合法性。一般根级的 CA 会内置在操作系统当中，当然如果向上找没有找到根级的 CA，那么将被视为不合法。 HTTPS协议分析 浏览器向服务器发送client_random和加密方法列表。 服务器接收到，返回server_random、加密方法以及公钥。 浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！) 服务器用公钥解密这个被加密后的pre_random。 现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。 然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。 事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。 回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？ 本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。 SSL/TLS协议 传输层安全性协议（Transport Layer Security - TLS），及其前身安全套接层（Secure Sockets Layer - SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障 HTTPS协议的安全性由SSL协议实现，当前使用的TLS协议 1.2 版本包含了四个核心子协议：握手协议、密钥配置切换协议、应用数据协议及报警协议 TLS适用于对称密钥 对称密钥可以通过安全密钥交换算法共享 如果请求被截获，密钥交换可能会被欺骗 使用数字签名进行身份验证 证书颁发机构和信任链 HTTPS协议、SSL协议、TLS协议、握手协议的关系 HTTPS是Hypertext Transfer Protocol over Secure Socket Layer的缩写，即HTTP over SSL，可理解为基于SSL的HTTP协议。HTTPS协议安全是由SSL协议实现的 SSL协议是一种记录协议，扩展性良好，可以很方便的添加子协议 握手协议是SSL协议的一个子协议 TLS协议是SSL协议的后续版本，本文中涉及的SSL协议默认是TLS协议1.2版本 TLS1.0 = SSL3.1 现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程。 TLS1.2分析 step 1: Client Hello ​ 首先，浏览器发送 client_random、TLS版本、加密套件列表。client_random 是什么？用来最终 secret 的一个参数。 ​ 加密套件列表是什么？我举个例子，加密套件列表一般长这样: TLS_ECDHE_WITH_AES_128_GCM_SHA256 ​ 意思是TLS握手过程中，使用ECDHE算法生成pre_random(这个数后面会介绍)，128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用SHA256算法。其中值得解释一下的是这个哈希摘要算法，试想一个这样的场景，服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息呢？现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要(可以理解为比较短的字符串)，用来标识这个服务端的身份，用私钥加密后把加密后的标识和自己的公钥传给客户端。客户端拿到这个公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓数字签名的原理。其中除了哈希算法，最重要的过程是私钥加密，公钥解密。 step 2: Server Hello ​ 可以看到服务器一口气给客户端回复了非常多的内容。 ​ server_random也是最后生成secret的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书，这都不难理解。那剩下的server_params是干嘛的呢？接下来接着看。 step 3: Client 验证证书，生成 secret ​ 客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递client_params这个参数给服务器。 ​ 接着客户端通过ECDHE算法计算出pre_random，其中传入两个参数:server_params和client_params。现在你应该清楚这个两个参数的作用了吧，由于ECDHE基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。 ​ 客户端现在拥有了client_random、server_random和pre_random，接下来将这三个数通过一个伪随机数函数来计算出最终的secret。 step4: Server 生成 secret ​ 刚刚客户端不是传了client_params过来了吗？ ​ 现在服务端开始用ECDHE算法生成pre_random，接着用和客户端同样的伪随机数函数生成最后的secret。 注意事项 TLS的过程基本上讲完了，但还有两点需要注意。 第一, 实际上 TLS 握手是一个双向认证的过程，从 step1 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？ 当然是可以的。具体来说，在 step3中，客户端传送client_params，实际上给服务器传一个验证消息，让服务器将相同的验证流程(哈希摘要 + 私钥加密 + 公钥解密)走一遍，确认客户端的身份。 第二, 当客户端生成secret后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完secret也会向客户端发送一个收尾的消息，告诉客户端以后就直接用对称加密来通信。 这个收尾的消息包括两部分，一部分是Change Cipher Spec，意味着后面加密传输了，另一个是Finished消息，这个消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下。 当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。 RSA 和 ECDHE 握手过程的区别 ECDHE 握手，也就是主流的 TLS1.2 握手中，使用ECDHE实现pre_random的加密解密，没有用到 RSA。 使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前抢跑，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫TLS False Start。 HTTPS SSL/TLS 分析 TLS 握手的步骤： ClientHello：客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给服务器端 ServerHello：服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法，返回给客户端 SendCertificate（可选）：服务器端发送服务端证书给客户端 RequestCertificate（可选）：如果选择双向验证，服务器端向客户端请求客户端证书 ServerHelloDone：服务器端通知客户端初始协商结束 ResponseCertificate（可选）：如果选择双向验证，客户端向服务器端发送客户端证书 ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端 CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通过收到的客户端公钥进行身份验证 CreateSecretKey：通讯双方基于密钥种子等信息生成通讯密钥 ChangeCipherSpec：客户端通知服务器端已将通讯方式切换到加密模式 Finished：客户端做好加密通讯的准备 ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式 Finished：服务器做好加密通讯的准备 Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密 ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息 TLS1.3 升级了啥先看下两张图的对比。 在分析TLS1.3究竟升级了什么之前，我们先来看看经过这么多年的优胜劣汰，还剩下什么加密算法。 TLS_AES_128_GCM_SHA256 TLS_AES_256_GCM_SHA384 TLS_CHACHA20_POLY1305_SHA256 TLS_AES_128_GCM_SHA256 TLS_AES_128_GCM_8_SHA256 很明显，总体来看，如今的加密算法，各个领域大概也就剩下两组。 对称加密：AES 和 CHACHA20 分组模式：GCM 和 POLY1305 哈希摘要算法：SHA256 和 SHA384 那么，TLS为什么会从1.2升级到1.3 第一、2015年发现了FREAK攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。 第二、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的secret，破解之前所有的密文。 为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成pre_random并用公钥加密传给服务器，服务器通过私钥解密，从而拿到真实的pre_random。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到pre_random、server_random和client_random并根据对应的随机数函数生成secret，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。 但ECDHE在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫前向安全性。 RSA 算法不具备前向安全性，而 ECDHE 具备，因此在 TLS1.3 中彻底取代了RSA。 回到正题，TLS究竟升级了啥？ TLS1.3大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。 这种 TLS 1.3 握手方式也被叫做1-RTT握手。但其实这种1-RTT的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。 再来优化一下 会话复用 Session ID 客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送ID过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。 Session Ticket 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用Session Ticket消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。 这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。 总的来说，这些会话复用的技术在保证1-RTT的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。 PSK （0-1） 在发送Session Ticket的同时带上应用数据，不用等到服务端确认，这种方式被称为Pre-Shared Key，即 PSK。 这种方式虽然方便，但也带来了安全问题。中间人截获PSK的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。 HTTPS大概就分析完了，跟着时间轴的推进，我们接下来看一下HTTP/2. HTTP2协议分析 HTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标 头字段等核心概念一如往常。 HTTP/2 修改了数据格式化(分帧)以及在客户端与服务器间传输的方 式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。 由于HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/ 1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。 HTTP2的特点: 1.使用二进制格式传输，更高效、更紧凑。 2.对报头压缩，降低开销。 3.多路复用，一个网络连接实现并行请求。 4.服务器主动推送，减少请求的延迟 5.默认使用加密 二进制分帧HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输 这里所谓的“层”指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制 HTTP/1.x 协议以换行符作为纯文本的分隔符，而HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码 客户端和服务器会替我们完成必要的分帧工作 首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输01串，方便了机器的解析。 原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。 通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。 可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？ 首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能。 每个帧分为帧头和帧体。先是三个字节的帧长度，这个长度表示的是帧体的长度。 然后是帧类型，大概可以分为数据帧和控制帧两种。数据帧用来存放 HTTP 报文，控制帧用来管理流的传输。 接下来的一个字节是帧标志，里面一共有 8 个标志位，常用的有 END_HEADERS表示头数据结束，END_STREAM表示单方向数据发送结束。 后 4 个字节是Stream ID, 也就是流标识符，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。 头部压缩在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程，通过Content-Encoding头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。 HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个： 首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如0，1，2，…)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。 HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开 方法 概述 请求/响应 :method 目标URL模式部分 请求 :scheme 目标URL模式部分 请求 :authority 目标RUL认证部分 请求 :path 目标URL的路径和查询部分（绝对路径产生式和一个跟着”？”字符的查询产生式）。 请求 :status 响应头中的HTTP状态码部分 响应 “:method” 伪头字段包含了 HTTP 方法 ([RFC7231], Section 4)。 “:scheme” 伪头字段包含了目标 URI 的一部分 scheme ([RFC3986],第 3.1 节)。”:scheme” 不限于 “http” 和 “https” scheme 的 URI。代理或网关可以对非 HTTP scheme 转换请求，从而使得 HTTP 与非 HTTP 服务进行交互。 “:authority” 伪头字段包含目标 URI 的部分权限([RFC3986],第 3.2 节)。权限不得包含 “http” 或 “https” scheme URI 的已弃用 “userinfo” 子组件。为了确保可以准确地再现 HTTP/1.1请求行，当从具有源或星号形式的请求目标的 HTTP/1.1 请求进行转换时，必须省略该伪头字段（参见[RFC7230]，第 5.3 节）。直接生成 HTTP/2 请求的客户端应该使用 “:authority” 伪头字段而不是 Host 头字段。将 HTTP/2 请求转换为 HTTP/1.1 的网络中间件必须通过复制 “:authority” 伪头字段的值来创建 Host 头字段（如果请求中不存在的话）。 “:path” 伪头字段包含目标 URI 的路径和查询部分。绝对路径和可选的 “?” 字符后的查询部分。（见[ RFC3986]的第 3.3 和 3.4 节），星号形式的请求包括 “:path” 伪头字段的值 ‘*‘。对于 “http” 或 “https” 的 URI，此伪头字段不能为空；不包含路径组件的 “http” 或 “https” 的 URI 必须包含值 “/“。此规则的例外是对不包含路径组件的 “http” 或 “https” 的 URI 的 OPTIONS 请求；这些必须包含一个 “:path” 伪头字段，其值为 ‘*’（参见 [RFC7230]，第 5.3.4 节）。 其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。 多路复用在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下 将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强。这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升 并行交错地发送多个请求，请求之间互不影响 并行交错地发送多个响应，响应之间互不干扰 使用一个连接并行发送多个请求和响应 不必再为绕过 HTTP/1.x 限制而做很多工作 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间 服务器推送HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求 HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流服务器已经知道客户端下一步要请求什么资源，这时服务器推送即可派上用场 推送资源可以进行以下处理 由客户端缓存 在不同页面之间重用 与其他资源一起复用 由服务器设定优先级 被客户端拒绝 小结当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如请求头、URI、状态码、头部字段都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。最后放一张分层图给大家参考: 了解HTTP 3运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3（HTTP-over-QUIC） QUIC 协议（Quick UDP Internet Connection）基于 UDP，正是看中了UDP 的速度与效率。同时 QUIC 也整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化 HTTP 3特点 减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开 HTTP 3与HTTP 1.1和HTTP 2没有直接的关系，也不是http2的扩展 HTTP 3将会是一个全新的WEB协议 HTTP 3目前处于制订和测试阶段 https://www.chromium.org/quic 队首阻塞问题HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking） HTTP/1.1 的队头阻塞。一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽资源 并发连接 对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。 但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。 域名分片 一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。 比如 content1.cnki.net 、content2.cnki.net。 这样一个cnki.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。 虽然有并发连接和域名分片的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。 而 HTTP/2 便从 HTTP 协议本身解决了队头阻塞问题。注意，这里并不是指的TCP队头阻塞，而是HTTP队头阻塞，两者并不是一回事。TCP 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。 正如我们上面所说，HTTP/2 的多路复用虽然可以解决“请求”这个粒度的阻塞，但 HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题 由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题 队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢 那 QUIC 解决队头阻塞问题的的方法: QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题 QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理 HTTP与代理 正向代理正向代理代理一般是指代理客户端，为客户端收发请求，使真实客户端对服务器不可见 反向代理反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见 反向代理的用途 加密和SSL加速 负载均衡 缓存静态内容 压缩 减速上传 安全 外网发布 反向代理做负载均衡反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率;","categories":[{"name":"http","slug":"http","permalink":"http://lo-que.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://lo-que.github.io/tags/http/"}]},{"title":"你给我翻译翻译，什么他妈的是他妈的dom diff","slug":"你给我翻译翻译，什么他妈的是他妈的dom-diff","date":"2021-07-24T03:40:21.000Z","updated":"2021-11-24T08:03:14.082Z","comments":true,"path":"2021/07/24/你给我翻译翻译，什么他妈的是他妈的dom-diff/","link":"","permalink":"http://lo-que.github.io/2021/07/24/%E4%BD%A0%E7%BB%99%E6%88%91%E7%BF%BB%E8%AF%91%E7%BF%BB%E8%AF%91%EF%BC%8C%E4%BB%80%E4%B9%88%E4%BB%96%E5%A6%88%E7%9A%84%E6%98%AF%E4%BB%96%E5%A6%88%E7%9A%84dom-diff/","excerpt":"","text":"上一次说废话还是在上一次近两年确实很少有人再分享dom diff原理(因为默认你必须得会)，但是想要完全的理解现在流行的使用Virtual DOM的前端框架，这也确是一个必须迈过去的坎。 比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。 两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级 的元素进行对比。下面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 实际的代码中,会对新旧两棵树进行一个深度优先的遍历,这样每个节点都会有一个唯一的标记,在深度优先遍历的时候,每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。p是patches[1],ul是patches[3],类推。 上边是diff的大致原理，各位看官看完了估计想骂街。就这？ 也是，这是烂大街的原理，接下来我们深度剖析一下。 vue2的dom diff我们就不去看了，毕竟vue3都出来了，还表示对diff进行了优化，所以原先的从头尾同时开始的diff明显被遗弃了。 所以，vue3的diff是怎么做的？ 去除双指针（罪过，我又鞭尸了） C1:[“a”,”b”,”c”,”d”,”g”,”f”] ✎ C2:[“a”,”e”,”b”,”d”,”c”,”f”] 从前往后比较,相同节点 [“a”] 进行 patch,遇到不相同的节点停止比较 从后往前比较,相同节点 [“f”] 进行 patch,遇到不相同的节点停止比较 如果 c1 中的所有节点都已经比较完了,c2 中剩余没有比较的节点都是新数据,执行 mount 如果 c2 中的所有节点都已经比较完了,c1 中剩余没有比较的节点都是需要删除的,执行 unmount 如果 c1 和 c2 中都有剩余节点,对剩余节点进行比较 找出需要删除的节点,执行 unmount 找出新、旧节点的对应关系,利用 “最长递增子序列” 优化节点的移动、新增。这一步是 diff 算法的核心 新元素没有比较完成的 keyToNewIndexMap[d:2,f:3,c:4,e:5,x:6,y:7] 根据未比较完的数据长度,建一个填充 0 的数组 [0,0,0,0,0,0] 老元素没有比较完成的 newIndexToOldIndexMap[4(d),6(f),3(c),5(e),0,0] 尾到头循环一下newIndexToOldIndexMap 是 0 的,说明是新增的数据,就 mount 进去非 0 的, 说明在旧数据里,我们只要把 它们移动到对应index的前面就行了 把 c 移动到 e 之前、把 f 移动到 c 之前、把 d 移动到 f 之前 上面很啰嗦 newIndexToOldIndexMap找到最长递增子序列 我们的 [4(d),6(f),3(c),5(e),0,0] 很明显能找到 [3,5] 是 数组中的最长递增子序列 于是乎 [3,5] 都不需要移动 最长递增子序列 ✄ patchKeyedChildren // c1 旧数据 [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;] // c2 新数据 [&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;b&quot;,&quot;f&quot;,&quot;i&quot;,&quot;g&quot;] ​ 要将 [“b”, “c” ,”d”] 变成 [“c”, “d”, “b”], c 、 d 不用动, 只需要将 b 移动到 d 之后就可以了,不需要将 c 和 d 分别移动到 b 之前。 最长递增子序列(longest increasing subsequence)问题是指,在一个给定的数值序列中,找到一个子序列,使得这个子序列元素的数值依次递增,并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。 那么React的是？React Diff 会预设几个规则: 只对同级节点,进行比较 节点变化,直接删除,然后重建 存在key值,对比节点的key值 单节点diff 判断存在对应节点,key值是否相同,节点类型一致,可以复用 存在对应节点,key值是否相同,节点类型不一致,标记删除 (div =&gt; p/span 会删除) 存在对应节点,key值不同,标记删除 不存在对应节点,创建新节点 多节点diff 对比新旧children相同index的对象的key是否相等, 如果是,返回该对象,如果不是,返回null key值不等,不用对比下去了,节点不能复用,跳出 判断节点是否存在移动,存在则返回新位置 但可能存在新的数组小于老数组的情况,即老数组后面有剩余的,所以要删除 新数组存在新增的节点,创建新阶段 创建一个existingChildren代表所有剩余没有匹配掉的节点,然后新的数组根据key从这个 map 里面查找,如果有则复用,没有则新建","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"vue diff, react diff","slug":"vue-diff-react-diff","permalink":"http://lo-que.github.io/tags/vue-diff-react-diff/"}]},{"title":"javascript执行堆栈","slug":"javascript执行堆栈","date":"2021-06-18T13:05:37.000Z","updated":"2021-11-24T07:45:45.015Z","comments":true,"path":"2021/06/18/javascript执行堆栈/","link":"","permalink":"http://lo-que.github.io/2021/06/18/javascript%E6%89%A7%E8%A1%8C%E5%A0%86%E6%A0%88/","excerpt":"","text":"javascript执行堆栈先来看两道面试题。 var a = &#123;n:1&#125; a.x = a = &#123;n:2&#125; console.log(a.x) // undefined var s = []; var arr = s; for (var i = 0; i &lt; 3; i++) &#123; var pusher = &#123; value: &quot;item&quot; + i &#125;, tmp; if (i !== 2) &#123; tmp = [] pusher.children = tmp &#125; arr.push(pusher); arr = tmp; &#125; console.log(s[0]); 概念 栈区(stack):由编译器自动分配释放,存放函数的参数值,局部变量的值等,其操作方式类似于数据结构的栈。 堆区(heap):一般是由程序员分配释放,若程序员不释放的话,程序结束时可能由OS回收,值得注意的是他与数据结构的堆是两回事,分配方式倒是类似于数据结构的链表。 全局区(static):也叫静态数据内存空间,存储全局变量和静态变量,全局变量和静态变量的存储是放一块的,初始化的全局变量和静态变量放一块区域,没有初始化的在相邻的另一块区域,程序结束后由系统释放。 文字常量区:常量字符串就是放在这里,程序结束后由系统释放。 程序代码区:存放函数体的二进制代码。 function foo() &#123; foo() &#125; foo() // ❌ function bar() &#123; setTimeout(bar) &#125; bar() // ✅ function baz() &#123; Promise.resolve().then(baz) &#125; baz() // 能运行，但是会卡 当Javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆 (heap)和 栈(stack) 中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。但是我们这里说的执行栈和数据结构中的栈的意义却有些不同。 js在执行可执行的脚本时，首先会创建一个全局可执行上下文 (globalContext)，每当执行到一个函数调用时都会创建一个可执行上下文 (Execution Context EC)。当然可执行程序可能会存在很多函数调用，那么就会创建很多EC， 所以javascript引擎创建了执行上下文栈 (Execution Context Stack, ECS)来管理执行上下文。但函数调用完成，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境…这个过程反复进行，直到执行栈中的代码全部执行完毕，如下是以上的几个关键词，我们来依次分析一下： 执行栈 (Execution Context Stack) 全局对象 (GO, Global Context) (因为垃圾回收叫GC，所以简单称为GO) 活动对象 (Activation Object) 变量对象 (Variable Object) 全局上下文 (GC, Global Execution Context) 执行上下文 (EC, Execution Context) 函数调用栈 (Callee Stack) 执行上下文栈 (ECS, Execution Context Stack) 垃圾回收 (GC, Garbage Collection) 词法环境 (Lexical Environment) 变量环境 (Variable Environment) 环境记录 (Environment Record) 【执行栈 (Execution Context Stack)】 执行栈，在其他编程语言中也被称为调用栈，它是一种LIFO（后进先出）的结构，被用于在代码执行阶段存储所有创建过的执行环境。 当Javascript引擎首次运行到你的脚本时，它会创建一个全局执行环境，并把它推入到当前的执行栈中。每当引擎运行到其函数调用时，就会为这个函数创建一个新的执行环境(栈帧)，并把它推入到堆栈的顶部。 浏览器解释器执行js是单线程的过程，这就意味着同一时间，只能有一个事情在进行。其他的活动和事件只能排队等候，生成出一个等候队列执行栈 执行栈压栈顺序一开始执行代码的时候，便确定了一个全局执行上下文global execution context作为默认值。如果在你的全局环境中，调用了其他的函数，程序将会再创建一个新的EC，然后将此EC推入进执行栈中execution stack 如果函数内再调用其他函数，相同的步骤将会再次发生：创建一个新的EC -&gt; 把EC推入执行栈。一旦一个EC执行完毕，便会从执行栈中推出(pop)。ESP指针负责EC出栈指向。 ECStack = [ · globalContext ] // 为啥全局变量永远不会回收 // 因为全局执行上下文永远不会弹出ECS // 全局执行上下文和 执行上下文都是概念 // 真正存储的是 // globalContext GO Global Context 全局对象 // execution context AO (Activation Object) 活动对象 VO(Variable Object)变量对象 继续分析压栈过程 function fun3() &#123; console.log(&#39;fun3&#39;) throw &#39;env&#39; // 通过抛出异常 我们可以简单的查看到当前函数的执行调度过程 &#125; function fun2() &#123; fun3() &#125; function fun1() &#123; debugger // 也可以 在此处追加debugger 从下图中看到 fun2() &#125; fun1() // 执行fun1 结果如下 ECStack = [ fun1, globalContext ] 我们按住 command + ; 继续向下走，会依次 fun2 –&gt; fun3 –&gt; fun2 —&gt; fun1 –&gt; anonymous(globalContext) 分别依次可以在上边的 Scope 选项中查看到当前执行栈的 this 指向 Local, 所以可以方便维护当前的执行上下文 函数的执行栈是有大小的. function foo1()&#123; foo1() &#125; foo1() // Uncaught RangeError: Maximum call stack size exceeded let m = 0 function foo()&#123; if(m++ &gt; 1000) &#123; debugger; &#125; foo() &#125; foo() // 就会发现调用栈中存在 1000 个调用 EC(栈帧) 变量对象 (Variable Object) 变量对象VO是与执行上下文相关的特殊对象，用来存储上下文的函数声明，函数形参和变量 // 变量对象VO存储上下文中声明的以下内容 &#123; // 1-1 函数声明FD(如果在函数上下文中), -- 不包含函数表达式 // 1-2 函数形参function arguments // 1-3 变量声明-注意b=10不是变量，但是var b = 10;是变量，有变量声明提升 // alert(a); //undefined // alert(b); //&quot;b&quot; 没有声明 // b = 10; // var a = 20; &#125; var a = 10; function test(x) &#123; var b = 20; &#125; test(30); // 全局上下文的变量对象 VO(global execution context) = &#123; a: 10, test: &lt;reference to function&gt; &#125; // test函数上下文的变量对象 VO(test functionContext) = &#123; x: 30, b: 20 &#125; // VO分为全局上下文的变量对象VO，函数上下文的变量对象VO VO(global execution context) === Global Context === globalThis; 活动对象(Activation Object) 在函数上下文中，变量对象被表示为活动对象AO，当函数被调用后，这个特殊的活动对象就被创建了。它包含普通参数与特殊参数对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。 // 1. 在函数执行上下文中，VO是不能直接访问的，此时由活动对象扮演VO的角色 // 2. Arguments对象包括如下属性：callee、length // 3. 内部定义的函数 // 4. 以及绑定上对应的变量环境 // 5. 内部定义的变量 VO(functionContext) === AO; function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125; (function x()&#123;&#125;) &#125; test(10); // call 当进入带有参数10的test函数上下文时， AO表现为如下： // AO里并不包含函数&quot;x&quot;。这是因为&quot;x&quot;是一个函数表达式(FunctionExpression, 缩写为FE)而不是函数声明，函数表达式不会影响VO AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt; e: undefined &#125; 活动对象和变量对象的区别: 变量对象（VO）是规范上或者是 JS 引擎上实现的,并不能在 JS 环境中直接访问 当进入到一个执行上下文后,这个变量对象才会被激活,所以叫活动对象(AO),这时候活动对象上的各种属性才能被访问,因为被激活了 深度活动对象 (Activation Object) // Activation Object 分为创建阶段和执行阶段 function foo(i) &#123; var a = &#39;hello&#39;; var b = function privateB() &#123;&#125;; function c()&#123;&#125; &#125; foo(22); // 当我们执行foo(22)的时候，EC创建阶段会类似生成下面这样的对象: fooExecutionContext = &#123; scopeChain:&#123; Scope &#125;, AO: &#123; arguments:&#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: undefined, b: undefined &#125;, VO:&#123;...&#125;, Scope: [AP, VO, GO] &#125; // 在创建阶段，会发生属性名称的定义，但是并没有赋值(变量提升阶段)。一旦创建阶段(creation stage)结束，便进入了激活/执行阶段。那么fooExecutionContext便会完成赋值，变成这样： // 【 运行函数内部的代码，对变量赋值，代码一行一行的被解释执行 】 fooExecutionContext = &#123; scopeChain:&#123; ... &#125;, AO: &#123; arguments:&#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: &#39;hello&#39;, b: pointer to function privateB() &#125;, VO:&#123;...&#125;, Scope: [AP, VO, GO], this: &#123; 运行时确认 &#125; &#125; 通过动图了解JS中的ECStack、EC、VO 和 AO 补充活动对象(Activation Object) var x = 10; function foo() &#123; var barFn = new Function(&#39;alert(x); alert(y);&#39;); barFn(); // 10, &quot;y&quot; is not defined &#125; foo() // 1. 通过函数构造函数创建的函数的[[scope]]属性总是唯一的全局对象(全局LexicalEnvironment) // 2. Eval code - eval 函数包含的代码块也有同样的效果 整合体运行流程如下 // VO函数上下文的链接 AO是函数自身的 ECStack = [ fun3, fun2, fun1, globalContext ] 写到最后 当一个异步代码(如发送ajax请求数据)执行后会如何呢？ 接下来需要了解的另一个概念就是： 事件队列(Task Queue)。 当js引擎遇到一个异步事件后，其实不会说一直等到异步事件的返回，而是先将异步事件进行挂起。等到异步事件执行完毕后，会被 加入到事件队列中。(注意，此时只是异步事件执行完成，其中的回调函数并没有去执行。)当执行队列执行完毕，主线程处于闲置状态时，会去异步队列那抽取最先被推入队列中的异步事件，放入执行栈中，执行其中的回调同步代码。如此反复，这样就形成了一个无限的循环。这就是这个过程被称为”事件循环(EventLoop)”的原因。 一个小实战 // =========分割线========== function test() &#123; var result = [] for(var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i &#125; &#125; return result &#125; let r = test() r.forEach(fn =&gt; &#123; console.log(&#39;fn&#39;, fn()) &#125;) /** 当去执行test的时候， test创建了EC放到ECS，直接创建完了就从ECS中直接就弹出去了，但是吐出来result，result里边包了十个fn，那么这十个函数，实际上最终指向了test中的AO，那就证明这个函数test执行完没有弹出，要等r.forEach(fn =&gt; console.log(&#39;fn&#39;, fn()))执行完才弹，因为fn指向了test中的AO里的i */ //1. 函数test执行**完**出栈 留下AO(test)有个i的指向 //2. 函数在执行的时候，函数的执行环境才会生成，所以 fn执行的时候生成作用域链指向如下 //3. AO(result[i]) --&gt; AO(fn) --&gt; VO(G) 加个闭包就立马创建了执行环境 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; var list_li = document.getElementByTagName(&quot;li&quot;) for(var i = 0; i &lt; list_li.length; i++) &#123; list_li[i].onclick = function () &#123; console.log(i) &#125; &#125; 那么其实一切也就迎刃而解。 闭包的原理就是Scope(对空间中存储closure(foo))， 在执行的作用域中遇到闭包，放到堆区中去，在Scope中指向了堆区 this的原理是动态绑定， this 永远指向ECS执行栈的栈顶 ‘谁调用指谁’ ECS栈顶执行出栈 动态绑定原理是 AO VO 两步 第一步在AO中定义 第二步等ECS执行 作用域的原理是Scope:[AO, VO, GO]. 再加上堆区的闭包 eval不能回收的原理是推不进AO， eval 直接绑定到全局中，进不了AO。EC出ECS(弹栈)的时候进行垃圾回收，弹栈的时候弹出去的是AO VO， GO不会出栈 变量提升的原理是AO的准备阶段， 把所有变量分析清楚，定义成undefined 异步队列的原理是ECS ECS中没有东西执行EventLoop。 node中 libuv 浏览器环境中 message loop message pump 走进ES5+ (出现了let const)// this 值的决定，也被称为 This Binding。(即 this 绑定) // LexicalEnvironment(词法环境) // VariableEnvironment(变量环境) ExecutionContext = &#123; ThisBinding = &lt;this value&gt;, // 固定this 因为有了箭头函数 LexicalEnvironment = &#123; ... &#125;, VariableEnvironment = &#123; ... &#125;, // 兼容var写法 &#125; 具体词法环境参考 9.1 Environment Records // 全局执行上下文 GlobalExectionContext = &#123; // 词法环境 LexicalEnvironment: &#123; // 环境记录 EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 全局环境 // ... 标识符绑定在这里 outer: &lt;null&gt;, // 对外部环境的引用 &#125; &#125; &#125; // 函数执行上下文 FunctionExectionContext = &#123; LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 函数环境 // ... 标识符绑定在这里 // 对全局环境或外部函数环境的引用 outer:&lt;Global or outer function environment reference&gt; &#125; &#125; &#125; 为了去适配早期的JS的var等，新的规范增加了变量环境(VariableEnvironment)。变量环境也是一个词法环境，其环境记录器包含了变量声明语句 在ES6中，词法环境组件和变量环境组件的区别在于前者用于存储函数声明和变量(let 和 const)绑定，而后者仅用于存储变量(var)绑定 let a = 20; const b = 40; var c; function multiply(e, f) &#123; var g = 20; return e*f*g; &#125; c = multiply(20, 30); // 全局执行上下文 GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, // 词法环境 LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定, let、const、函数声明 a: &lt;uninitialized&gt;, b: &lt;uninitialized&gt;, multiply: &lt;func&gt; &#125; outer: &lt;null&gt; &#125;, // 变量环境 VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定，var 声明 c: undefined, &#125; outer:&lt;null&gt; &#125; &#125; FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;, VariableEnvironment : &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 在这里绑定标识符 g: undefined, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125; &#125; 以上let和const定义的变量并没有关联任何值uninitialized(未初始化)，但var定义的变量被初始化成undefined。这也就是造成TDZ的原因了。 接下来就是执行阶段，完成对所有变量的分配，最后执行代码。无论是ES3还是ES5，上下文的生命周期包括三个阶段：创建阶段-&gt;执行阶段-&gt;回收阶段。 参考文献： :http://262.ecma-international.org/6.0/#sec-execution-contexts :https://medium.com/@itIsMadhavan/what-is-the-execution-context-stack-in-javascript-e169812e851a :https://www.ecma-international.org/wp-content/uploads/ECMA-262_1st_edition_june_1997.pdf :https://github.com/tc39 图解JS词法环境(Lexical environment) variable-environment-vs-lexical-environment xikun’s blog javascript 执行环境，变量对象，作用域链 深入理解JavaScript执行上下文、函数堆栈、提升的概念 翻译文档 Functions MDN","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"GC VO AO CalleeStack","slug":"GC-VO-AO-CalleeStack","permalink":"http://lo-que.github.io/tags/GC-VO-AO-CalleeStack/"}]},{"title":"前端性能优化杂谈","slug":"前端性能优化","date":"2021-05-05T13:46:35.000Z","updated":"2021-11-24T08:00:42.294Z","comments":true,"path":"2021/05/05/前端性能优化/","link":"","permalink":"http://lo-que.github.io/2021/05/05/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"前端性能优化杂谈当我刚开始进入前端这个行业时，在我的认知里，性能优化是一个形而上的东西。 这事儿一直到我第一份工作才有了变化。当时部门进来了一个 10 年+工作经验的大佬，我喊他刘哥。刘哥每天早上一到工位，就对着一群花花绿绿姹紫嫣红入了定。诺，就这玩意儿。 我一看，嚯，好家伙，这玩意儿我熟(见过)啊。介不是chrome自带的performance吗。显然，年轻的我还没有意识到，事情正在朝着伟大刹不住车。code review的时候，我才意识到，我平常做的说好听点儿叫业务，不好听就是搬砖。刘哥做的才叫产出，从请求的缓冲调度，到页面的渲染优化，相当于对整个项目做了一次深度体检并提供了解决方案。性能优化间有大恐怖（笑 可能随着年龄增长的，除了体重还有自知之明。自此，我对性能优化上了心。 从网络层面讲先放张神图。 我们先来了解一下这图里都发生了什么。 首先看主模块 缓存相关：主要包括Prompt for unload,redirect和App cache3 个过程 网络相关：主要包括DNS,TCP和HTTP(Request,Response)3 个过程 浏览器相关：主要包括Processing(dom 处理)和onload两个过程 Prompt for unload 首先卸载掉原来的页面。这是为了释放页面占据的内存，否则每请求一次 URL 都占据一份内存，会导致浏览器占据内存越来越大。实际上这个阶段是预处理的，真正性能分析计时是从prompt for unload结束开始,navigationStart。有个很明显的佐证，在navigation-timing-2中， Redirect 本地重定向，处理缓存。先走App cache，判断要请求的资源是不是被强制缓存，不是的话走-&gt;网络相关模块。 被嵌入的unload模块是在真正卸载之前的页面（Prompt for unload在做准备）,也在处理之前的unload事件 App cache 从本地找缓存，强制缓存。如果不是强缓存，自然会走尝试协商缓存，如果命中协商缓存也会重新回到 App cache，读取缓存。(和强制缓存不同的是强制缓存会直接读取缓存，协商缓存需要服务器判断) 都没有命中的的话自然会重新请求资源。此处先补充一点 DNS TCP 相关知识 DNS DNS(Domain Name System)域名系统，顾名思义是用来解析域名系统的。在网络中，我们人适合于记忆文本，因此我们输入的都是https://www.google.com这种字符串，但是计算机适合于处理数字，每一台计算机对应的是一个 IP 地址。因此，如果我们要访问一个指定的资源，必须先找到对应的服务器，而找到服务器需要先将域名转换为对应的 IP 地址。而 DNS 就是帮助我们实现这个过程。域名服务器本质上是个数据库，保存了域名和 ip 的对应关系。 域名级别 域名的级别是指一个域名由多少级组成，域名的各个级别被”.”分开，总而言之，有多少个点就是几级域名。 顶级域名在开头有一个点(.com .cn .net) 一级域名就是在”com cn net”前加一级 (https://google.com) 二级域名就是在一级域名前再加一级(https://www.google.com) 二级域名及以上级别的域名，统称为子域名，不在注册域名的范畴中 域名资源记录 记录类型 含义 SOA:(StartOf Authority, 起始授权记录) ⼀个区域解析库有且只能有⼀个 SOA 记录，⽽且必须放在第⼀条 A 记录(主机记录) 用于名称解析的重要记录，将特定的主机名映射到对应主机的 IP 地址上 CNAME 记录(别名记录) ⽤于返回另⼀个域名，即当前查询的域名是另⼀个域名的跳转，主要⽤用于域名的内部跳转，为服务器器配置提供灵活性 NS 记录(域名服务器记录) 用于返回保存下⼀级域名信息的服务器地址。该记录只能设置为域名，不能设置为 IP 地址 MX(邮件记录) ⽤于返回接收电子邮件的服务器地址 IPv6 主机记录(AAAA 记录) 与 A 记录对应，用于将特定的主机名映射到⼀个主机的 IPv6 地址 dns 解析过程 域名的解析需要用到一系列的服务器，而不是简单的一个服务器。比如：用户想要解析 www.google.com: 在本机上输入https://www.google.com 2 号服务器是用户在自己电脑上填写的 DNS 地址，由于域名和 ip 地址的对照表非常庞大，因此 2 号服务器会进行分层管理。2 号服务器进行域名解析是会先从缓存中进行查找，如果一个域名被频繁访问，通常会被保存到缓存中。如果 DNS 这没有对应的域名-IP 缓存，那么就需要向根服务器(Root Server)发起请求。 根服务器负责维护全球的域名-IP 地址解析。根服务器会检查域名后缀(比如.com)，根据不同的后缀，交给不同的 TLD 服务器处理。获取到后缀后，返回对应的 TLD 服务器的 ip 地址(com = 1.1.1.1)。 DNS 拿到 TLD 服务器的 IP 地址后，继续向 TLD 服务器进行询问。TLD 服务器只返回顶级域名对应的 IP(https://google.com = 2222)，交给顶级域名对应的 Name Server 处理。 DNS 服务器获取到顶级域名的 IP 后，继续向 Name Server 进行询问。Name Server 返回具体的域名对应的 IP 地址。 DNS 服务器获取到具体的域名对应的 IP 后，会先进行缓存，避免下次请求时继续多次询问。 TCP TCP 是 HTTP 的下层协议，我们想要通过 HTTP 进行请求，必须先通过 TCP 进行连接，也就是说 HTTP 是依赖于 TCP 的。TCP 的作用就是连接指定 IP 地址的服务器(通过 DNS 已经获取到对应的服务器 IP 地址)。 每次连接的时候，通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。 进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。 断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。 DOS 拒绝服务攻击 DDOS 分布式拒绝服务攻击 大量请求 半连接状态攻击，大量发起连接请求，但是不接受响应 具体在网络安全相关分析。 浏览器相关下节再具体分析。 接下来我们看下标签很明显navigationStart是开始，查看Navagation Timing可知 interface PerformanceTiming &#123; readonly attribute unsigned long long navigationStart; readonly attribute unsigned long long unloadEventStart; readonly attribute unsigned long long unloadEventEnd; readonly attribute unsigned long long redirectStart; readonly attribute unsigned long long redirectEnd; readonly attribute unsigned long long fetchStart; readonly attribute unsigned long long domainLookupStart; readonly attribute unsigned long long domainLookupEnd; readonly attribute unsigned long long connectStart; readonly attribute unsigned long long connectEnd; readonly attribute unsigned long long secureConnectionStart; readonly attribute unsigned long long requestStart; readonly attribute unsigned long long responseStart; readonly attribute unsigned long long responseEnd; readonly attribute unsigned long long domLoading; readonly attribute unsigned long long domInteractive; readonly attribute unsigned long long domContentLoadedEventStart; readonly attribute unsigned long long domContentLoadedEventEnd; readonly attribute unsigned long long domComplete; readonly attribute unsigned long long loadEventStart; readonly attribute unsigned long long loadEventEnd; &#125;; 这也是我们进行性能分析赖以依据的指标。 unload 拥有Start和End两个指标, 表示开始结束。实际上整个 unload 过程中，这两个时间指标都被上一个页面的 unload 事件占据，你瞧，这里就是一个优化点。显而易见的，onload 事件是加载时的事件，也不应该拥有过多的操作。 fetch start 指的是 http 做好准备的时间。因为App cache一直到整个网络相关流程结束，对于浏览器来讲都属于拿资源的时间。终止标识为responseEnd。 DNS存在两个标签domainLookupStart domainLookupEnd,分别表示，发起解析 dns 请求，返回解析后的数据(返回 ip 地址)。如果在当前 dns 解析比较慢的话，就要去考虑是不是 dns 服务器、服务器地址有问题。 拿到 IP 地址之后就要开始 http 事务。1. 建立 tcp 连接 2. 发起请求 3.接受响应 4. 断开 tcp 连接 。很明显 tcp 模块中只有建立连接和连接成功不包含断开 tcp 的标签，这是因为考虑到 tcp 的复用。如果是 https 的话，还会多出一个 secureConnectionStart 先建立普通连接，然后加密。这里的瓶颈在于网络质量。首先是链路质量，从计算机到服务器，会收到干扰(wifi 光缆 光纤)；其次是通信质量，一部分是网络信号，另一部分是链路长度。部署服务器遵循就近原则，cdn 分发，找到响应最快的服务器。所以这块有瓶颈，要去做 cdn 的优化。 为什么没有requestEnd，requestStart属于请求开始(客户端向服务端发送第一个字节的时候开启)，客户端发送完最后一个字节，但是不一定发出去，存在丢包重传的过程，即使完全发出去了，服务端收到全部请求也要进行处理，而服务端处理数据也属于请求(因为可能存在出错)。举例来说，我们去火车站买票，询问工作人员你是否有去北京的票，这个时候并不能获得结果，因为工作人员还有自己的工作流程，直到工作人员把票递出，才算响应。你把票拿到手才算响应结束。如果之间存在问题，比如没有票(404)，就收不到响应，只能得到一个状态 404；比如车次取消了，重定向。所以，reponseStart是客户端收到服务端传来的第一个字节的时间，最后一个字节收到是responseEnd, 而不是最后一个字节发出。 而Request、Response的瓶颈在于一在于网络链路，二在于数据大小，第三点在于服务器处理性能。 Processing，以 html 举例， 首先是domLoading，请求返回的是一个文本，我们需要将文本转换成 DOM 树，生成 DOM。 domInteractive，开始解析 dom 树。如果遇到 js 会先处理 js。 domContentLoaded，dom 解析结束。 domComplete，dom 整个结束 所以整个Processing几乎全部在处理 dom，当然也可能会存在一部分 js 加载。 生成 dom 树，在此基础上生成渲染树(css 规则)，在渲染树基础上再生成，层树(排版规则)。 之后就要处理页面上的事件。 onLoad，执行完 onLoad 事件后，gpu 开始工作。 Processing 很明显，接下来我们要把重点放到Processing 现代浏览器渲染过程再看张图。 这就是现代浏览器的结构。 用户界面(User Interface) 浏览器引擎(Browser Engine) 渲染引擎(Rendering Engine) 将 HTML/CSS/JavaScript 文本及相应的资源文件转换成图像结果 eg: Trident Gecko Webkit Blink(Webkit fork) 网络(Networking) XML 解析器(XML Parser) 显示后端(Display Backend) 数据持久层(Data Persistence) 我们的重心就在渲染引擎。下图是渲染引擎的简单工作流程。 首先看一下整体，输入 HTML/CSS/JavaScript 三大幻神，经过渲染引擎，将图像输出到浏览器显示。具体做了什么呢，大概分成了 4 个步骤。 Parsing HTML to construct DOM Tree. 解析 HTML，生成 DOM 树(包括处理 js css)。渲染引擎使用 HTML 解析器（调用 XML 解析器）解析 HTML（XML）文档，将各个 HTML（XML）元素逐个转化成 DOM 节点，从而生成 DOM 树。 同时，渲染引擎使用 CSS 解析器解析外部 CSS 文件以及 HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree Construction. 生成渲染树。(将样式挂载到相应的节点上)。渲染引擎使用第 1 步 CSS 解析器解析得到的样式规则，将其附着到 DOM 树上，从而构成渲染树。 渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree. 布局树。排版规则。渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree. GPU 渲染到屏幕上。渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 知道大致流程之后，我们再细化一下每一个步骤将要做什么。 下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第 1 步和第 2 步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 由图可知, HTML Parser 先工作，生成 dom 树，在生成 dom 的过程中，JS 解析引擎(safari 中是 js core， chrome v8)开始工作。很明显的是，先开始处理 HTML，扫描到 css 处理 css，扫描到 js 就处理 js，同时进行。很显眼的是，DOM Tree 和 JavaScript Interperter 是双向箭头，在 js 解析过程中，可以修改 dom 树，所以 js 会阻塞 dom 加载。小程序的渲染加载和此不同，这个之后再表。根据我们以往的编码经验来看，js 不仅可以操纵 dom，还可以修改 css。css Parser 在解析完 css 后首先遍历整个 dom 树。从*开始，依次附着到 dom 树上。接下来要进行排版，为每个节点分配一个应出现在屏幕上的确切坐标。最后就要交给 GPU，需要转换坐标系。第一个坐标系以左上角为原点，第二个坐标系计算可显示区域。所以进行拖拽改变了排列布局，也会重新绘制。重排必重绘。 小结 HTML（XML）解析器 解析 HTML（XML）文档，主要作用是将 HTML（XML）文档转换成 DOM 树。 CSS 解析器 将 DOM 中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript 解释器 使用 JavaScript 可以修改网页的内容、CSS 规则等。JavaScript 解释器能够解释 JavaScript 代码，并通过 DOM 接口和 CSSOM 接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM 创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 接下来我们详细聊聊，在 chrome 中究竟是怎么做的。 从 chrome 的架构谈起 Browser：主进程。控制程序的“chrome”部分，包括地址栏，书签，后退和前进按钮。还处理 Web 浏览器的不可见的，和特权部分，例如网络请求和文件访问 Renderer：负责显示网站的选项卡内的所有内容。一个域名一个渲染进程 Plugin：控制网站使用的所有插件，例如 flash GPU：独立于其他进程的 GPU 处理任务。 它被分成多个不同的进程，因为 GPU 处理来自多个程序的请求并将它们绘制在同一个面中 渲染器进程 渲染器进程负责选项卡内发生的所有事情。 在渲染器进程中，主线程处理你为用户编写的大部分代码 如果你使用了 web worker 或 service worker，有时 JavaScript 代码的一部分将由工作线程处理。 排版和栅格线程也在渲染器进程内运行，以便高效、流畅地呈现页面 渲染过程: 解析部分 构建 DOM 子资源加载 注意 JavaScript 可以阻止解析 提示浏览器如何加载资源 样式表计算 布局 绘制 渲染过程: 合成部分 把文档的结构、元素的样式、几何形状和绘制顺序转换为屏幕上的像素称为光栅化 合成是一种将页面的各个部分分层，分别栅格化，并在一个被称为合成器线程的独立线程中合成为页面的技术 渲染过程: GPU 渲染 一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。 合成器线程然后栅格化每个图层。 一个图层可能像页面的整个长度一样大，因此合成器线程会将它们分成图块，并将每个图块发送到光栅线程(Raster)。 栅格线程栅格化每一个瓦片(tile)并将它们存储在 GPU 内存中 通过 IPC 将合成器帧提交给浏览器进程。这时可以从 UI 线程添加另一个合成器帧以用于浏览器 UI 更改，或者从其他渲染器进程添加扩充数据。 这些合成器帧被发送到 GPU 用来在屏幕上显示。 如果发生滚动事件，合成器线程会创建另一个合成器帧并发送到 GPU 合成的好处是它可以在不涉及主线程的情况下完成。 合成线程不需要等待样式计算或 JavaScript 执行。 这就是合成动画是平滑性能的最佳选择的原因。 如果需要再次计算布局或绘图，则必须涉及主线程 既然都到这里了，不看看 Webkit 多少说不过去。 WebKit 官网：https://webkit.org/ Blink 是未来 Blink 官方文档：http://www.chromium.org/blink 上图是 Webkit 的架构图，当然，在 blink 中 JsCore 为 V8。 天也不早了，闲扯这么多，也该进入正题了。 性能调优为什么需要性能优化？ 57%的⽤户更在乎⽹⻚在 3 秒内是否完成加载 52%的在线⽤户认为⽹⻚打开速度影响 到他们对⽹站的忠实度 每慢 1 秒造成⻚⾯ PV 降低 11%，⽤户满意度也随之降低降低 16% 近半数移动⽤户因为在 10 秒内仍未打开⻚⾯从⽽放弃 Google Developers 优化性能指导 性能优化学徒工 压缩 顾名思义，减小文件大小。具体压缩大小推荐为经过 gzip 后28-31kb，而 webpack 会在 gzip 之前就将大于 30kb 的文件提出来为一个单独的 js 文件。 合并 减少请求数量，多个请求合并成一个请求。但是会有两个问题，一是文件会变大，而且可能产生大量闭包。二是合并多少请求个数才合适。5 个请求合并成一个是否合理。eg：大多数情况下，一个 cdn 对应 5 个请求。 为什么要强调一个 cdn。我们打开 baidu 看一下，携带了很大的 Cookie。也可以很明显的看到在 cdn 上，不会携带多余的 Cookie。使用多个 CDN，解决浏览器对同一个域名的并发限制。 content-encoding: brotli &gt;&gt;&gt; gzip keep-alive http2 多路复用 浏览器请求//xx.cn/a.js–&gt;解析域名—&gt;HTTP 连接—&gt;服务器处理文件—&gt;返回数据–&gt;浏览器解析、渲染文件。Keep-Alive 解决的核心问 题就在此，一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求 效率的问题。一定时间是可以配置的，HTTP1.1 还是存在效率问题，第一个:串行的文件传输。第二个:连接数过多。HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样 Apache 的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 60 倍! 更详细阅读，参考 雅虎军规 35 条 缓存策略 强缓存，协商缓存。 详情请参考《http 协议的那些事儿》 离线缓存 Manifest Service Workers 解决了 Manifest 的所有缺点。所有文件可以进行管控，哪些过期，可以进行请求拦截 Storage 容量每个域名下限制 5M 可通过使用隐藏 iframe 的方式扩容，通过 postMessage 通信，但是会违背 localStorage 的核心，localStorage 是同步的。低端机 localStorage 使用超过一定容量的时候会造成明显的卡顿。 此处最常见的优化方式通过使用 localStorage 进行离线存储。通过一个 loaderjs 判断 version 的方式来动态加载(直接 inner 进入对应的 script 标签) 雅虎军规 雅虎军规 35 条 网速机型 提到网速就不得不提一个 API ———— navigator.connection 参考 MDN Navigator 很明显，这个类型不准，因为通过网速判断类型。 还有其他方式进行判断吗？ 资源请求 小 img 实现 在服务器放个 1KB 的图片，并请求，看返回Timer差分区间 bandwidth = file_size/Timer 多普勒测速 分五次请求，计算公式 performance a &lt;= &lt;random number&gt; http://a-doppler.facebook.com/test_pixel?HTTP1.0&amp;t=1&amp;size=0k T1 http://a-doppler.facebook.com/test_pixel?HTTP1.1&amp;t=2&amp;size=0k T2 http://a-doppler.facebook.com/test_pixel?HTTP1.1&amp;t=3&amp;size=0k T3 http://a-doppler.facebook.com/test_pixel?HTTP1.1&amp;t=4&amp;size=10k T4 http://a-doppler.facebook.com/test_pixel?HTTP1.1&amp;t=5&amp;size=40k T5 http://a-doppler.facebook.com/test_pixel 地址可更换为 Api 地址 关于个 T(0, 3) 阶段查看 navigation-timing 对应位置 T1 = DNS + New Connection(TCP) + RTT(一次传输) T2 = New Connection(TCP) + RTT(一次传输) T3 = RTT(一次传输) bandwidth(带宽) = 10k/(t4-t3) bandwidth(带宽) = (40k-10k)/(t5-t4) 得到用户网络状态之后，可以根据网络状态加载对应大小的图片。通过 css srcset 属性进行动态改变。 当然也可以高级一点，通过记录用户常用 ip 记录下来用户网络状态等数据来进行动态加载(_WISE_INFO)。 渲染加载先来测试一下基础。 渲染是一回事儿 解析是一回事儿 DOM 的解析不必等待底部的 js 但是渲染依旧需要等待 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;js会不会影响html的渲染解析？&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;js不影响DOM解析，渲染依旧需要等待&lt;/h1&gt; &lt;script&gt; prompt(&#39;等待&#39;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; css 加载会阻塞 dom 树的渲染 但不会影响 dom 解析 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;css的加载会不会阻塞dom的渲染解析？&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h1 &#123; color: red !important; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 观察一下h1是否解析 function h () &#123; console.log(document.querySelectorAll(&#39;h1&#39;)) &#125; setTimeout(h, 0) &lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/1.4.0/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 观察一下h1是否渲染 --&gt; &lt;h1&gt;css加载会阻塞dom树的渲染 但不会影响dom解析&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; css 加载会阻塞后面的 js 语句的执行 js 可能会操作 css &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;css会不会阻塞js的执行？&lt;/title&gt; &lt;script&gt; console.log(&#39;before css&#39;) var start = new Date() &lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/1.4.0/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;css加载会阻塞后面的js语句的执行 因为js可能会操作css&lt;/h1&gt; &lt;script&gt; var end = new Date() console.log(&#39;after css&#39;) console.log(&#39;经过了&#39; + (end - start) + &#39;ms&#39;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; css 阻塞 domready？ 看 css 后边有没有 js 代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;css会阻塞domready吗&lt;/title&gt; &lt;script&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, function (e) &#123; console.log(&#39;DOMContentLoaded&#39;) &#125;) &lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/1.4.0/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;css阻塞domready&lt;/h1&gt; &lt;script&gt; console.log(&#39;hello world&#39;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 聊了这么多，这时候我们来看下现在最流行的 MVVM 框架 Vue。SPA spa 系统 加载到 index.html 也只是一个壳子&lt;div id=&quot;app&quot;&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt;&lt;/div&gt; 作为一个正常的 Web APP 加载 min.js，5 个属于经验值，6 个及以上的话就要考虑到defer async async defer 要慎用。 首先是浏览器的支持程度 其次是 defer 和 async 的不同，由上图可以明显的看出来 async 等 js 加载完直接阻断 html 解析开始执行当前加载完的 js，defer 等 html 解析完再按顺序执行。 所以 async 更适合可以不依赖任何脚本或不被任何脚本依赖的脚本 vue.min.js -&gt; vue-router.min.js -&gt; vuex -&gt; axios -&gt; element ui 很明显，这是串行的。vue-router/vuex 都依赖于 vue 进行加载。为什么说 vuex 不如 redux，这也是很重要的原因。加载到这里就结束了吗？还没有后边还有 runtimes.js -&gt; common.js(业务公用+小 lib (date.js)) -&gt; main.js 这也是 spa 首页白屏的核心原因。 fecth -&gt; 虚拟 dom -&gt; dom diff（react 工作树 首次加载不 diff vue 还是 diff） -&gt; 不可操作 -&gt; 事件引擎 web 应用有个很明显的指标，可见可操作，然而单页应用就很明显，可见也不可操作。可想而知，性能也很差。接下来我们就要想想如何优化 mpa 用户等待时间非常的长。因为把所有的业务逻辑放到后端去做，之后再 render。这就导致 html 体积变得巨大！！ 解决方案就是使用 bigpipe可见可操作 页面落地时全是 a 链接，不掺杂任何的 JS，先跳转 a 链接，之后再去加载 JS。 spa+mpa 这种方案使用了假路由 historyfallback api/data index/test 当匹配到真实存在的路由时，正常通过路由加载，如果匹配到 404 就跳转回系统首页 比如说 vue-router 的 history 这种方案也并没有完全解决我们的问题。只能说解决了后端的耦合性，维护成本也比较高。所以通过无头浏览器 prerender 的方式更占据主流。 在 webpack 打包结束并生成文件后(after-emit-hook)， 会启动一个 server 模拟网站的运行，用 puppeteer(google 官方的 headless 无头浏览器)访问指定的页面 route，得到相应的 html 结构，并将结果输出到指定目录，过程类似于爬虫。 即利用打包工具对应用进行预先渲染，让用户首次获取到 HTML 文件的时候就已经能看到我们的内容，接着等到 Bundle 下载解析完成之后再进行接管。 打包构建与渲染的核心原理又是什么呢？其实这里就要用到我们十分强大的无头浏览器来帮助实现这项功能了，他会在本地启动一个无头浏览器，并访问我们配制好的路由，接着将渲染好的页面 HTML 内容输出到我们的 HTML 文件中，并建立相关的目录。 一般常用的无头浏览器有:phantomjs, puppeteer, 对于 prerender-spa-pulgin 插件来说，内部采用了 phantomjs 作为无头浏览器作为渲染 5 的升级版本。让 spa+mpa 发挥最大优势。mpa 的最大优势是什么？页面直接渲染出来，如果觉得 html 慢，使用 bigpipe，解决了白屏的问题。但是多页的缺点在于，每个页面渲染时都要重复加载一些请求。 [判断请求头] index/test 直接刷新 –&gt; koa.render 站内点击 –&gt; {html:””,js:””,css:””} vue-router 拦截到这段 json，通过 pushstate 改变路由、fecth 请求 但是使用了两套模板 node.js + koa-swig + vue.js 可以抛弃中间商，直接 node.js + vue.js (a.vue / b.vue) ，通过 nodejs render 【Isomorphic JavaScript】同构 四种常见的方式 spa mpa 假 spa + mpa 真 spa + mpa 这些都是网络层的相关知识 接下来终于进入正题，看一下页面的渲染。 看一段测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; padding: 30px; text-align: center; &#125; .container &#123; position: relative; min-height: 400px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125; .ball &#123; position: absolute; top: 0; left: 0; width: 100px; height: 100px; border-radius: 50%; box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.75); &#125; .ball-running &#123; -webkit-animation: run-around 4s infinite; animation: run-around 4s infinite; &#125; @keyframes run-around &#123; 0% &#123; top: 0; left: 0; /* transform: translate(0, 0); */ &#125; 25% &#123; top: 0; left: 200px; /* transform: translate(200px, 0); */ &#125; 50% &#123; top: 200px; left: 200px; /* transform: translate(200px, 200px); */ &#125; 75% &#123; top: 200px; left: 0; /* transform: translate(0, 200px); */ &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;ball&quot; id=&quot;ball&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var balls = document.getElementById(&#39;ball&#39;) balls.classList.add(&#39;ball&#39;) balls.classList.add(&#39;ball-running&#39;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 上图中有一些关键参数 Loading 加载 js 时长 scripting js 执行花费时 rendering 重排 painting 重绘 system 系统时长 因为系统也会执行 js Idle 空闲 我们也能根据这些参数得到一些结论 使用 top left 会发现不断的 重绘和重排 使用 transform 则没有 Paint flashing 将会显示绿色代表重绘(使用 transform 所以没有，切换为 top left 可见) Layout 重排 网页渲染流程 获取 dom 分层 真实的 dom 结构不是 2d 的，如下图所示是 3d 的，还有个 Z 轴![Firefox for Developers: Introducing Firefox 3D View - YouTube](/2021/05/05/前端性能优化/Firefox for Developers: Introducing Firefox 3D View - YouTube.jpeg) 对每个图层节点计算样式 Recalculate Style 为每个对应的节点生成图形和位置 Layout 回流重排 将每个节点绘制填充到图层(即将作为纹理)位图中 Paint 绘制好的图交给 gpu 纹理 GPU 对它进行旋转缩放 Composite Layers 合成层 把符合多个图层生成到页面最终的图像 Layout Paint Composite Layers 究竟干了点儿啥 Composite Layers 的流程 (自占线程) 图层通过 GPU 绘制好的时候 主线程会把该图层 commit 到合成线程 合成线程根据 viewport 图层进行分块 tile rendering 图块大小 256*256/512*512 （之前测试代码中，绿色的就是重绘，紫色的是重排） GPU 将 tile 生成位图 栅格化来完成生成位图 raster 所有的图块都被光栅化后，合成线程会生成一个绘制图块的命令 DrawQuad，再交给浏览器进程 浏览器里边有一个 viz 组件，专门用来接收 DrawQuad。将这些页面的内容绘制到内存中，最终通过 chrome 的应用程序看见页面 当 GPU 首次接收到 CPU 传递的位图的旋转缩放，先绘制一张低分辨率的图，继续绘制，完成后替换。 Layout Paint Composite Layers 独立成层 会触发元素分层 根元素、position、transform、半透明、css 滤镜、canvas 、video、overflow 会有 GPU 参与(css 3d 硬件加速) CSS3D、video、webgl、transform、css 滤镜、will-change:transform 重排必重绘 重绘不一定重排 box-sizing：border-box 尽量减少元素的重排 css 盒模型 盒子动了 怪异盒模型 offset scroll client width/height 读写 // 尽量把读操作和写操作放到一起,或者在下一帧执行写操作: const width = doucument.getElementbyid(&#39;xx&#39;).width // DOcumentFragment内存dom requestAnimationFrame(function () &#123; // react // 设置dom元素 读写分离 &#125;) cpu 主要负责操作系统和程序，gpu 负责显式 数据处理 效率更高 gpu.js fastdom 控制读写分离的插件 csstriggers 可查看是否引起重排重绘 参考流程 样式流程 渲染进程 结论 在能使用 css 3d 硬件加速的地方尽量使用，以此优化 dom 的性能，极大的减少 dom 的重绘重排 既然要对页面加载进行性能优化，优先要知道都有哪些指标，根据不同的情况做调优 为页面渲染各个阶段的标识符，可以通过计算得到 https://web.dev/ 阶段(简写) 描述 阶段(全称) TTFP 首字节时间 Time TO Frist Byte FP 首次绘制(第一个节点) First Paint FCP 首次有内容的绘制(骨架) First Contentful Paint FMP 首次有意义的绘制(包含所有元素/数据) First Meaningful TTI 达到可交互时间，推荐的响应时间是 100ms 以内否则有延迟 Time To Interactive Long tasks 超过了 50ms 的任务 SSR&amp;&amp;CSR 服务端渲染和客户端渲染 Server-Side-Rendering / Client Side Rendering Isomorphic 同构化 FP、FCP、FMP(已经废弃)、TTI LongTask 新增指标 LCP、FID、TBT、CLS 阶段(简写) 描述 阶段(全称) LCP 最⼤内容绘制，⽤于记录视窗内最⼤的元素绘制的时间，该时间会随着⻚⾯渲染变化⽽变化，因为⻚⾯中的最⼤元素渲染过程中可能会发⽣改变，另外该指标会在⽤户第⼀次交互后停⽌记录 LCP（Largest Contentful Paint） FID ⾸次输⼊延迟，记录在 FCP 和 TTI 之间⽤户⾸次与⻚⾯交互时响应的延迟 FID（First Input Delay） TBT 阻塞总时间，记录在 FCP 到 TTI 之间所有⻓任务的阻塞时间总和 TBT（Total Blocking Time） CLS 累计位移偏移，记录了⻚⾯上⾮预期的位移波动。使⽤按钮动态添加了某个元素，导致⻚⾯上其他位置的代码发⽣了偏移，造成了⻚⾯ CLS（Cumulative Layout Shift） 简单的指标标准 LCP: 代表了⻚⾯的速度指标，LCP 能体现的东⻄更多⼀些。⼀是指标实时更新，数据更精确，⼆是代表着⻚⾯最⼤元素的渲染时间，最⼤元素的快速载⼊能让⽤户感觉性能还挺好。 FID: 代表⻚⾯的交互体验指标，交互响应的快会让⽤户觉得⽹⻚流畅。 CLS: 代表了⻚⾯的稳定指标，尤其在⼿机上这个指标更为重要。因为⼿机屏幕⼩，CLS 值较⼤的话会让⽤户觉得⻚⾯体验做的很差。 说了这么多指标，那么到底如何获取指标呢？可以通过浏览器自带 Api 性能监测对象 MDN PerformanceObserver 访问。 PerformanceObserver &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: orange; &#125; &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/5.0.0-alpha1/css/bootstrap-reboot.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;target&lt;/h1&gt; &lt;script&gt; performance.mark(&#39;target&#39;) &lt;/script&gt; &lt;/div&gt; &lt;script&gt; const observer = new PerformanceObserver(list =&gt; &#123; for (const entry of list.getEntries()) &#123; console.log(entry.name) console.log(entry.startTime) console.log(entry.duration) console.log(entry.entryType) &#125; &#125;) observer.observe(&#123; entryTypes: [&#39;paint&#39;, &#39;mark&#39;, &#39;longtask&#39;] &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; entryType 更为详细的描述请参考 entryType 属性 描述 frame, navigation 文件的地址。 resource 所请求资源的解析 URL。即使重定向请求，此值也不会更改。 mark 通过调用创建标记时使用的名称 performance.mark()。 measure 通过调用创建度量时使用的名称 performance.measure()。 paint 可能是 first-paint 或 first-contentful-paint。 longtask 在浏览器执行超过 50ms 的任务 到此为止吗？可以通过 PerformanceTiming 可以获取浏览器的指标信息，关于 dns 解析时间，tcp 耗时，request 请求耗时，解析 dom 树耗时，白屏时间，domready 时间，onload 时间，js 内存使用占比等。和之前的整个渲染流程 Callback const t = performance.timing console.log( &#39;DNS查询耗时 ：&#39; + (t.domainLookupEnd - t.domainLookupStart).toFixed(0) ) console.log(&#39;TCP链接耗时 ：&#39; + (t.connectEnd - t.connectStart).toFixed(0)) console.log(&#39;request请求耗时 ：&#39; + (t.responseEnd - t.responseStart).toFixed(0)) console.log(&#39;解析dom树耗时 ：&#39; + (t.domComplete - t.domInteractive).toFixed(0)) console.log(&#39;白屏时间 ：&#39; + (t.responseStart - t.navigationStart).toFixed(0)) console.log( &#39;domready时间 ：&#39; + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0) ) console.log(&#39;onload时间 ：&#39; + (t.loadEventEnd - t.navigationStart).toFixed(0)) if ((t = performance.memory)) &#123; console.log( &#39;js内存使用占比 ：&#39; + ((t.usedJSHeapSize / t.totalJSHeapSize) * 100).toFixed(2) + &#39;%&#39; ) &#125; 也可以通过第三方库获取NPM: web-vitals 可以获取的指标有：CLS、FID、LCP、以及 FCP、TTFB import &#123; getCLS, getFID, getLCP &#125; from &#39;web-vitals&#39; getCLS(console.log) getFID(console.log) getLCP(console.log) 知道这么多页面指标有什么用呢？我们可以做一个小型的监控系统 通过上述的方法拿到自己想要的指标 去服务器上请求 一个 1KB 大小的图片 并带上这些指标参数 使用 navigator.sendBeacon() 发送， 参考 sendBeacon Node 读取服务器日志 过滤有效的接口 对接口参数整理并进行分析 开启定时任务每天凌晨 开始读取数据并绘制出图表 Q: 为什么使用 navigator.sendBeacon() 进行发送? A: navigator.sendBeacon() 方法可用于通过 HTTP 将少量数据异步传输到 Web 服务器 而不占用进程 发送可以使用的优先级: navigator.sendBeacon() &gt; ajax &gt; fetch 所以，白屏产生的真正原因是什么呢？ 主要分为 css &amp; js 文件获取 阻塞 js 文件解析 dom 生成 cssom 生成 优化调优 包含基本 dom 基本的 css 骨架屏 在 vue 中的各个阶段 created 阶段 为 FP 阶段，仅有一个 div 根节点(空节点) mounted 节点 为 FCP 节点，包含⻚面的基本框架，但没有数据内容 update 阶段 为 FMP 阶段 挂载数据，视图更新 优化调优 在 FP 阶段，创建简单的骨架片，基本的 dom 结构 总结 优/缺 CSR 预渲染 SSR 同构 优点 1. 不依赖数据2. FP 时间最快3. 客户端用户体验好4. 内存数据共享 1. 不依赖数据2. FCP时间比CSR快3. 客户端体验好4. 内存数据共享 1. SEO 友好2. 首屏性能高，FMP 比 CSR 和预渲染快 1. SEO 友好2. 首屏性能高，FMP 比 CSR 和预渲染快3. 客户端用户体验好4. 内存数据共享5. 客户端与服务端代码共用，开发效率高 缺点 1. SEO 不友好2. FCP FMP 慢 1. SEO 不友好2. FMP 慢 1. 客户端数据共享成本高2. 模版维护成本高 1. Node 容易形成性能瓶颈","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://lo-que.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"踩坑addEventListener","slug":"踩坑addEventListener","date":"2019-06-12T15:30:30.000Z","updated":"2021-11-24T02:52:57.538Z","comments":true,"path":"2019/06/12/踩坑addEventListener/","link":"","permalink":"http://lo-que.github.io/2019/06/12/%E8%B8%A9%E5%9D%91addEventListener/","excerpt":"","text":"今天遇到一个问题。 因为是老项目，很老那种，老到称不上屎山。所以，总是会有一些历史遗留问题待处理，或设计遗留问题，或逻辑遗留问题。 这次的问题出在addEventListener身上。事实上不是addEventListener有什么问题，问题出现在使用上。 业务逻辑且不去细究，大抵是一个需求需要做统计，需要对部分dom节点的addEventListener绑定的方法重写。这个事情非常麻烦，因为不知道都在哪些地方做了针对性处理，不能完全重写覆盖。 思前想后，想到了用proxy。 代码如下： (w =&gt; &#123; w.listenerList = new Set() const _cache = w.addEventListener const handler = &#123; apply: (target, thisBinding, args) =&gt; &#123; target() listenerList.add(args[0]) //_cache.apply(w, args) Reflect.apply(_cache, w, args) &#125; &#125; w.addEventListener = new Proxy((eventName, fn) =&gt; &#123; console.log(eventName,fn) &#125;, handler) &#125;)(window) window.addEventListener(&#39;resize&#39;, () =&gt; &#123; console.log(&#39;-----------&#39;) &#125;) window.addEventListener(&#39;a&#39;, () =&gt; &#123; console.log(&#39;-----------&#39;) &#125;) for(const val of listenerList) &#123; console.log(val) &#125;","categories":[{"name":"picking up","slug":"picking-up","permalink":"http://lo-que.github.io/categories/picking-up/"}],"tags":[{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"}]},{"title":"从二进制开始学数学","slug":"从二进制开始学数学","date":"2019-04-10T13:44:45.000Z","updated":"2019-06-12T15:26:42.000Z","comments":true,"path":"2019/04/10/从二进制开始学数学/","link":"","permalink":"http://lo-que.github.io/2019/04/10/%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%95%B0%E5%AD%A6/","excerpt":"","text":"//TODO 实现位运算","categories":[{"name":"Computer basis","slug":"Computer-basis","permalink":"http://lo-que.github.io/categories/Computer-basis/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://lo-que.github.io/tags/Math/"}]},{"title":"闭包","slug":"闭包","date":"2018-06-17T08:22:46.000Z","updated":"2021-11-24T02:36:39.988Z","comments":true,"path":"2018/06/17/闭包/","link":"","permalink":"http://lo-que.github.io/2018/06/17/%E9%97%AD%E5%8C%85/","excerpt":"","text":"私以为，也算是个拾遗。 动这个心思当源于顺丰的面试。二面的面试官的确是当前遇见的状态最好的一个面试官了，不苟言笑却也平易近人。 此前，我理解中的闭包的确是炫技一般的回答，曾几何时，还暗自窃喜。 **在程序语言范畴内的“闭包”指的是函数把其中的变量作用域都“包”在该函数的作用域内，形成一个“包”，外部函数无法访问内部变量。所以严格意义上来说，JavaScript 中的函数都是闭包。但我们常说的闭包，通常是指为了让外部函数访问到内部函数中变量，使内部函数返回一个函数，在其中操作内部变量。 ** Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must in- clude not only the code of the function but also a reference to the current scope chain. (Before reading the rest of this section, you may want to review the material on variable scope and the scope chain in §3.10 and §3.10.3.) This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. (This is an old term that refers to the fact that the function’s variables have bindings in the scope chain and that therefore the function is “closed over” its variables.) Technically, all JavaScript functions are closures: they are objects, and they have a scope chain associated with them. Most functions are invoked using the same scope chain that was in effect when the function was defined, and it doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked under a different scope chain than the one that was in effect when they were defined. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first en- counter them, but it is important that you understand them well enough to use them comfortably. 摘自 JavaScript, The Definite Guide 手写一个最简单的闭包也是手到擒来。 function foo(sth) &#123; function bar(message) &#123; console.log(sth + &#39; &#39; + code + &#39;!&#39;) &#125; return bar &#125; foo(&#39;Hello&#39;)(&#39;closure&#39;) 之后面试官问我为什么会用闭包。 闭包的优缺点自然熟记于心，然而闭包的原因却不曾深究。 首先MDN对闭包的解释为： Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created. 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。 提及闭包就必然会涉及到作用域。闭包的产生也正是因为ES6之前并不存在块级作用域。 函数内部可以直接访问外部变量，但在函数外部无法访问函数内部变量。这也就是Javascript语言特有的“链式作用域”结构（chain scope）。为了在函数外部访问函数内部变量，所以出现了闭包。 举例面试中最常见的setTimeout； for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i * 1000 ); &#125; //要求改动上述代码，使其依次输出1、2、3、4、5 显而易见的是以上代码输出6，6，6，6，6。 for (var i = 1; i &lt;= 5; i++) &#123; (function(j)&#123; setTimeout( function timer() &#123; console.log(j); &#125;, j * 1000 ); &#125;)(i); &#125; 关于setTimeout 还有其他有意思的事，比如task和job，当然ES2015之前叫做macro-task以及micro-task。现在揭过不提。 此为最常见的闭包，但是闭包仅如此吗？ //一个闭包的简单例子 function buildFunctions()&#123; var funcArr = []; for(var i = 0; i &lt; 3; i++)&#123; funcArr.push(function()&#123;console.log(i)&#125;); &#125; return funcArr; &#125; var fs = buildFunctions(); fs[0](); //3 fs[1](); //3 fs[2](); //3 此时，i 作为一个闭包变量，当前值为3，被内部函数使用，想要实现想要的效果，在遍历的时候每一次遍历的时候创建一个独立的上下文使其不受闭包影响。使用自触发函数实现独立上下文。 function buildFunctions()&#123; var funcArr = []; for(var i = 0; i &lt; 3; i++)&#123; funcArr.push((function(j)&#123; return function()&#123; console.log(j); &#125;; &#125;(i))); &#125; return funcArr; &#125; var fs = buildFunctions(); fs[0](); //0 fs[1](); //1 fs[2](); //2 闭包的两个方面：一个是内部函数使用闭包变量，另一个是把内部函数写在自触发函数中从而避免受闭包影响。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"}]},{"title":"闭合浮动与BFC","slug":"闭合浮动与BFC","date":"2018-04-30T13:40:12.000Z","updated":"2021-11-24T02:45:56.363Z","comments":true,"path":"2018/04/30/闭合浮动与BFC/","link":"","permalink":"http://lo-que.github.io/2018/04/30/%E9%97%AD%E5%90%88%E6%B5%AE%E5%8A%A8%E4%B8%8EBFC/","excerpt":"","text":"在火币工作的日子里，遭遇一新鲜事儿。因为是新人，有个带我的小师傅。因为PRO站全部都是float布局，所以写新的future的时候，小师傅专门交待了记得清除浮动。在做code review的时候突然想起这茬，所以在父元素中添加了clear:both;然而毫无变化。定睛一看，喔唷，已经是清理过浮动之后的样式了。仔细看了一下代码，做了测试，发现习惯性添加在父元素里的overflow:hidden已经实现了清除浮动的效果。 也由此引申出了BFC的概念。 BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 下列方式会创建块格式化上下文： 根元素（&lt;html&gt;） 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display 为 table、``table-row、 table-row-group、``table-header-group、``table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table） overflow 计算值(Computed)不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content 或 paint 的元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 ``column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 块格式化上下文包含创建它的元素内部的所有内容。 块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。","categories":[{"name":"css","slug":"css","permalink":"http://lo-que.github.io/categories/css/"}],"tags":[{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"}]},{"title":"在https中引入http资源","slug":"在https中引入http资源","date":"2018-04-30T13:39:37.000Z","updated":"2018-04-30T13:45:01.000Z","comments":true,"path":"2018/04/30/在https中引入http资源/","link":"","permalink":"http://lo-que.github.io/2018/04/30/%E5%9C%A8https%E4%B8%AD%E5%BC%95%E5%85%A5http%E8%B5%84%E6%BA%90/","excerpt":"","text":"在进行个人网站的维护中，遇到了在https中引入http资源的问题，本以为是需要进行资源跨域访问解决，后来无意间发现How to Disable Mixed Content Security Warning in Google Chrome &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;","categories":[{"name":"network","slug":"network","permalink":"http://lo-que.github.io/categories/network/"}],"tags":[{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"}]},{"title":"css 命名规范","slug":"css-命名规范","date":"2018-01-24T03:17:11.000Z","updated":"2018-04-25T07:35:32.000Z","comments":true,"path":"2018/01/24/css-命名规范/","link":"","permalink":"http://lo-que.github.io/2018/01/24/css-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"","text":"Learnning Notecss命名规范base头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签页：tab 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：register 状态：status 投票：vote 合作伙伴：partner 注释/* Header */ 内容区 /* End Header */ id的命名:(1)页面结构容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center (2)导航导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary (3)功能标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop（如购物车） 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guide 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class命名(1)颜色:使用颜色的名称或者16进制代码,如.red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } (2)字体大小,直接使用”font+字体大小”作为名称,如.font10px { font-size: 10px; } .font6pt {font-size: 6pt; } (3)对齐样式,使用对齐目标的英文名称,如.left { float:left; } .bottom { float:bottom; } (4)标题栏样式,使用”类别+功能”的方式命名,如.barnews { } .barproduct { } ** 注意事项: ** 1. 一律小写; 2. 尽量用英文; 3. 不加中杠和下划线; 4. 尽量不缩写； class 名称中只能出现小写字符和连字符（不是下划线，也不是驼峰命名法）。连字符应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 样式命名1） 主要的 master.css布局，版面 layout.css专栏 columns.css文字 font.css打印样式 print.css主题 themes.css 2）reset.css // 对浏览器的默认样式进行重设layout.css // 管理页面的布局typeset.css // 图文的编排color.css // 统一管理颜色的搭配print.css // 打印效果样式ie.css // 把对ie的hack单独分开 3）reset.cssheader.css // 头部的所有样式container.css // 除头部/底部外的中间区域样式footer.css // 底部样式print.cssie.css 4）reset.css /* 页面样式重置 /header.css / 全站头部样式 /footer.css / 全站尾部样式 /public.css / 全站公共模块样式 /index.css / 首页特有样式 /container.css / 二级及以下主体样式 /print.css / 打印样式 /ie.css / IE hack */","categories":[{"name":"css","slug":"css","permalink":"http://lo-que.github.io/categories/css/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"underscore学习小结","slug":"underscore学习小结","date":"2018-01-22T12:38:34.000Z","updated":"2018-04-25T07:37:09.000Z","comments":true,"path":"2018/01/22/underscore学习小结/","link":"","permalink":"http://lo-que.github.io/2018/01/22/underscore%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/","excerpt":"","text":"underscore.jsUnderscore.js 是一个由Jeremy Ashkenas开发的JavaScript库，提供了许多作为开发者在开发Web项目时所需要的实用功能。 代码变得更加易读： _.isEmpty(&#123;&#125;) //true 代码更容易编写： _.flatten([[0, 1], [2, 3], [4, 5]]) // [0, 1, 2, 3, 4, 5] 提供了原生没有的方法： _.range(5) //[0, 1, 2, 3, 4] 甚至可以作为模版引擎： _.template(&#39;&lt;p&gt;&lt;%= text %&gt;&lt;/p&gt;&#39;, &#123;text: &#39;SitePoint Rocks!&#39;&#125;) // &lt;p&gt;SitePoint Rocks!&lt;/p&gt; USA Today 今日美国 LinkedIn 领英 Khan Academy 可汗学院 集合：数组或对象 each 对集合循环操作，只针对function //遍历数组或者对象的每个元素 // 第一个参数为数组（包括类数组）或者对象 // 第二个参数为迭代方法，对数组或者对象每个元素都执行该方法 // 该方法又能传入三个参数，分别为 (item, index, array)（(value, key, obj) for object） // 与 ES5 中 Array.prototype.forEach 方法传参格式一致 // 第三个参数（可省略）确定第二个参数 iteratee 函数中的（可能有的）this 指向 // 即 iteratee 中出现的（如果有）所有 this 都指向 context // notice: _.each 方法不能用 return 跳出循环（同样，Array.prototype.forEach 也不行） _.each([1, 2, 3], function (ele, idx) &#123; console.log(idx + &quot;:&quot; + ele); &#125;); =&gt; 0:1 1:2 2:3 map 对集合以map方式进行遍历，返回一个新数组 iteratee 可以是对象或字符串 console.log( _.map([1, 2, 3], function(num)&#123; return num * 3; &#125;) ); =&gt; [3, 6, 9] reduce: 按callback缩减集合 console.log( _.reduce([1, 2, 3], function (memo, num) &#123; return memo + num; &#125;, 0) ); =&gt; 6 filter: 过滤器 _.find = _.detect 返回第一个 console.log( _.filter([1, 2, 3, 4, 5, 6], function(num)&#123; return num &amp; 1 == 0; &#125;) ); =&gt; [ 2, 4, 6 ] reject: 过滤不符合要求的 console.log( _.reject([1, 2, 3, 4, 5, 6], function(num)&#123; return num &amp; 1 == 0; &#125;) ); =&gt; [ 1, 3, 5 ] where: 根据指定键值对 遍历list，返回新的数组。（类似于sql语句中的where）&amp;： find 返回第一个 var list = [ &#123;title:&quot;AAA&quot;,year: 1982&#125;, &#123;title:&quot;BBB&quot;,year: 1900&#125;, &#123;title:&quot;CCC&quot;,year: 1982&#125; ]; console.log( _.where(list,&#123;year: 1982&#125;) ); =&gt; [ &#123; title: &#39;AAA&#39;, year: 1982 &#125;, &#123; title: &#39;CCC&#39;, year: 1982 &#125; ] _.contains = _.includes = _.include: 判断数组或者对象中（value 值）是否有指定元素 every = all 所有满足 返回true some = any 只有有一个满足 返回true invoke: 数组或者对象中的每个元素都调用 method 方法，返回调用后的结果（数组或者关联数组） pluck: 提取一个集合里指定的属性值 var users = [ &#123;name: &#39;moe&#39;, age: 40&#125;, &#123;name: &#39;larry&#39;, age: 50&#125; ]; console.log( _.pluck(users, &#39;name&#39;) ); =&gt; [ &#39;moe&#39;, &#39;larry&#39; ] max,min,sortBy: 取list中的最大，最小元素，自定义比较器 console.log( _.max(users, function (stooge) &#123; return stooge.age; &#125;) ); =&gt; &#123; name: &#39;larry&#39;, age: 50 &#125; var numbers = [10, 5, 100, 2, 1000]; console.log( _.min(numbers) ); =&gt; 2 console.log( _.sortBy([3, 4, 2, 1 , 6], function (num) &#123; return Math.max(num); &#125;) ); =&gt; [ 1, 2, 3, 4, 6 ] ​ groupBy: 把一个集合分组成多个集合 console.log( _.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;) ); =&gt; &#123; &#39;3&#39;: [ &#39;one&#39;, &#39;two&#39; ], &#39;5&#39;: [ &#39;three&#39; ] &#125; countBy: 把一个数据分组后计数 onsole.log( _.countBy([1, 2, 3, 4, 5], function (num) &#123; return num % 2 == 0 ? &#39;even&#39; : &#39;odd&#39;; &#125;) ); =&gt; &#123; odd: 3, even: 2 &#125; toArray: 将list转换成一个数组 console.log( (function () &#123; return _.toArray(arguments).slice(1); &#125;)(1, 2, 3, 4) ); =&gt; [ 2, 3, 4 ] size: 得到list中元素个数 console.log( _.size(&#123;one: 1, two: 2, three: 3&#125;) ); shuffle 随机打乱 洗牌算法 partition 将数组或者对象中符合条件的元素和不符合条件的元素分别放入两个数组 数组 _.first = _.head = _.take 返回前n个元素 n默认为1 initial 返回出去后n个元素的数组 last 返回后n个元素 rest = tail 返回出去前n个元素 compact 去除数组中所有的假值 false null undefined ‘’ NaN 0 √ flatten 将数组展开 //input =&gt; Array 或者 arguments // shallow =&gt; 是否只展开一层 // strict === true，通常和 shallow === true 配合使用 // 表示只展开一层，但是不保存非数组元素（即无法展开的基础类型） // flatten([[1, 2], 3, 4], true, true) =&gt; [1, 2] // flatten([[1, 2], 3, 4], false, true) = &gt; [] // startIndex =&gt; 从 input 的第几项开始展开 // ===== // // 可以看到，如果 strict 参数为 true，那么 shallow 也为 true // 也就是展开一层，同时把非数组过滤 // [[1, 2], [3, 4], 5, 6] =&gt; [1, 2, 3, 4] var flatten = function(input, shallow, strict, startIndex) &#123; // output 数组保存结果 // 即 flatten 方法返回数据 // idx 为 output 的累计数组下标 var output = [], idx = 0; // 根据 startIndex 变量确定需要展开的起始位置 for (var i = startIndex || 0, length = getLength(input); i &lt; length; i++) &#123; var value = input[i]; // 数组 或者 arguments // 注意 isArrayLike 还包括 &#123;length: 10&#125; 这样的，过滤掉 if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123; // flatten current level of array or arguments object // (!shallow === true) =&gt; (shallow === false) // 则表示需深度展开 // 继续递归展开 if (!shallow) // flatten 方法返回数组 // 将上面定义的 value 重新赋值 value = flatten(value, shallow, strict); // 递归展开到最后一层（没有嵌套的数组了） // 或者 (shallow === true) =&gt; 只展开一层 // value 值肯定是一个数组 var j = 0, len = value.length; // 这一步貌似没有必要 // 毕竟 JavaScript 的数组会自动扩充 // 但是这样写，感觉比较好，对于元素的 push 过程有个比较清晰的认识 output.length += len; // 将 value 数组的元素添加到 output 数组中 while (j &lt; len) &#123; output[idx++] = value[j++]; &#125; &#125; else if (!strict) &#123; // (!strict === true) =&gt; (strict === false) // 如果是深度展开，即 shallow 参数为 false // 那么当最后 value 不是数组，是基本类型时 // 肯定会走到这个 else-if 判断中 // 而如果此时 strict 为 true，则不能跳到这个分支内部 // 所以 shallow === false 如果和 strict === true 搭配 // 调用 flatten 方法得到的结果永远是空数组 [] output[idx++] = value; &#125; &#125; return output; &#125;; without 从数组中移除指定的元素，返回移除后的数组副本 union,intersection,difference,uniq: 并集，交集，差集，取唯一(去重) zip unzip 合并数组中的元素 是group的反向操作 indexOf,lastIndexOf, 取索引位置 sortedIndex 二分查找 function createIndexFinder(dir, predicateFind, sortedIndex) ​ 函数 bind: this指向不变 bindAll 绑定方法名到对象上, 当这些方法被执行时将在对象的上下文执行. 绑定函数用作事件处理时非常方便, 否则函数调用时 this 关键字根本没什么用 var func = function(greeting)&#123; return greeting + &#39;: &#39; + this.name &#125;; func = _.bind(func, &#123;name : &#39;moe&#39;&#125;, &#39;hi&#39;); console.log(func()); =&gt; hi: moe var buttonView = &#123; label : &#39;underscore&#39;, onClick : function()&#123; console.log(&#39;clicked: &#39; + this.label); &#125;, onHover : function()&#123; console.log(&#39;hovering: &#39; + this.label); &#125; &#125;; var func = _.bindAll(buttonView, &#39;onClick&#39;, &#39;onHover&#39;); func.onClick(); =&gt; clicked: underscore ​ partial:在不改变this的情况下，通过参数填充数据 可以使方法设定默认值 柯里化(Currying) var add = function(a, b) &#123; return a + b; &#125;; add5 = _.partial(add, 5); console.log(add5(10)); =&gt; 15 ​ memoize 记忆化，存储中间运算结果，提高效率 // 参数 hasher 是个 function，用来计算 key // 如果传入了 hasher，则用 hasher 来计算 key // 否则用 key 参数直接当 key（即 memoize 方法传入的第一个参数） // _.memoize(function, [hashFunction]) // 适用于需要大量重复求值的场景 // 比如递归求解菲波那切数 var fibonacci = _.memoize(function(n) &#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); &#125;); console.log(fibonacci(10)); =&gt; 55 ​ delay: 延迟触发 setTimeout _.defer = _.partial ( _.delay, _, 1); throttle: 函数节流（如果有连续事件响应，则每间隔一定时间段触发） // 每间隔 wait(Number) milliseconds 触发一次 func 方法 // 如果 options 参数传入 &#123;leading: false&#125; // 那么不会马上触发（等待 wait milliseconds 后第一次触发 func） // 如果 options 参数传入 &#123;trailing: false&#125; // 那么最后一次回调不会被触发 // options 不能同时设置 leading 和 trailing 为 false // 示例： // var throttled = _.throttle(updatePosition, 100); // $(window).scroll(throttled); // 调用方式（注意看 A 和 B console.log 打印的位置）： // _.throttle(function, wait, [options]) // sample 1: _.throttle(function()&#123;&#125;, 1000) // print: A, B, B, B ... // sample 2: _.throttle(function()&#123;&#125;, 1000, &#123;leading: false&#125;) // print: B, B, B, B ... // sample 3: _.throttle(function()&#123;&#125;, 1000, &#123;trailing: false&#125;) // print: A, A, A, A ... debounce: 函数去抖（连续事件触发结束后只触发一次） // sample 1: _.debounce(function()&#123;&#125;, 1000) // 连续事件结束后的 1000ms 后触发 // sample 1: _.debounce(function()&#123;&#125;, 1000, true) // 连续事件触发后立即触发（此时会忽略第二个参数） wrap 以函数作为函数传递，可以增加函数前后的控制 var hello = function(name) &#123; return &quot;hello: &quot; + name; &#125;; hello = _.wrap(hello, function(func) &#123; return &quot;before, &quot; + func(&quot;moe&quot;) + &quot;, after&quot;; &#125;); console.log(hello()); =&gt; before, hello: moe, after ​ compose: 组合函数调用关系，把单独的f(),g(),h()组合成f(g(h())) 对象 // Keys in IE &lt; 9 that won&#39;t be iterated by `for key in ...` and thus missed. // IE &lt; 9 下 不能用 for key in ... 来枚举对象的某些 key // 比如重写了对象的 `toString` 方法，这个 key 值就不能在 IE &lt; 9 下用 for in 枚举到 // IE &lt; 9，&#123;toString: null&#125;.propertyIsEnumerable(&#39;toString&#39;) 返回 false // IE &lt; 9，重写的 `toString` 属性被认为不可枚举 // 据此可以判断是否在 IE &lt; 9 浏览器环境中 var hasEnumBug = !&#123;toString: null&#125;.propertyIsEnumerable(&#39;toString&#39;); // IE &lt; 9 下不能用 for in 来枚举的 key 值集合 //为什么constructor要和nonEnumerableProps区分处理 // 个人觉得可能是 `constructor` 和其他属性不属于一类 // nonEnumerableProps[] 中都是方法 // 而 constructor 表示的是对象的构造函数 // 所以区分开来了 var nonEnumerableProps = [&#39;valueOf&#39;, &#39;isPrototypeOf&#39;, &#39;toString&#39;, &#39;propertyIsEnumerable&#39;, &#39;hasOwnProperty&#39;, &#39;toLocaleString&#39;]; ​ keys,values,paris,invert: 取属性名，取属性值，把对象转换成[key,value]数组，对调键值 var obj = &#123;one: 1, two: 2, three: 3&#125; console.log(_.keys(obj)); console.log(_.values(obj)); console.log(_.pairs(obj)); console.log(_.invert(obj)); =&gt; [ &#39;one&#39;, &#39;two&#39;, &#39;three&#39; ] [ 1, 2, 3 ] [ [ &#39;one&#39;, 1 ], [ &#39;two&#39;, 2 ], [ &#39;three&#39;, 3 ] ] &#123; &#39;1&#39;: &#39;one&#39;, &#39;2&#39;: &#39;two&#39;, &#39;3&#39;: &#39;three&#39; &#125; ​ extend: 复制对象的所有属性到目标对象上，覆盖已有属性 defaults: 复制对象的所有属性到目标对象上，跳过已有属性 console.log( _.extend(&#123;name : &#39;moe&#39;&#125;, &#123;age : 50&#125;) ); =&gt; &#123; name: &#39;moe&#39;, age: 50 &#125; var iceCream = &#123;flavor : &quot;chocolate&quot;&#125;; console.log( _.defaults(iceCream, &#123;flavor : &quot;vanilla&quot;, sprinkles : &quot;lots&quot;&#125;) ); =&gt; &#123; flavor: &#39;chocolate&#39;, sprinkles: &#39;lots&#39; &#125; 1. pick,omit: 返回一个对象的副本，保留指定的属性或去掉指定的属性 2. tag: 用对象作为参数来调用函数，作为函数链式调用的一环 3. isEqual: ```javascript // &quot;内部的&quot;/ &quot;递归地&quot;/ &quot;比较&quot; // 该内部方法会被递归调用 var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren&#39;t identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). // a === b 时 // 需要注意 `0 === -0` 这个 special case // 0 和 -0 被认为不相同（unequal） // 至于原因可以参考上面的链接 if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. // 如果 a 和 b 有一个为 null（或者 undefined） // 判断 a === b if (a == null || b == null) return a === b; // Unwrap any wrapped objects. // 如果 a 和 b 是 underscore OOP 的对象 // 那么比较 _wrapped 属性值（Unwrap） if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. // 用 Object.prototype.toString.call 方法获取 a 变量类型 var className = toString.call(a); // 如果 a 和 b 类型不相同，则返回 false // 类型都不同了还比较个蛋！ if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. // 以上五种类型的元素可以直接根据其 value 值来比较是否相等 case &#39;[object RegExp]&#39;: // RegExps are coerced to strings for comparison (Note: &#39;&#39; + /a/i === &#39;/a/i&#39;) case &#39;[object String]&#39;: // Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is // equivalent to `new String(&quot;5&quot;)`. // 转为 String 类型进行比较 return &#39;&#39; + a === &#39;&#39; + b; // RegExp 和 String 可以看做一类 // 如果 obj 为 RegExp 或者 String 类型 // 那么 &#39;&#39; + obj 会将 obj 强制转为 String // 根据 &#39;&#39; + a === &#39;&#39; + b 即可判断 a 和 b 是否相等 // ================ case &#39;[object Number]&#39;: // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN // 如果 +a !== +a // 那么 a 就是 NaN // 判断 b 是否也是 NaN 即可 if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. // 排除了 NaN 干扰 // 还要考虑 0 的干扰 // 用 +a 将 Number() 形式转为基本类型 // 即 +Number(1) ==&gt; 1 // 0 需要特判 // 如果 a 为 0，判断 1 / +a === 1 / b // 否则判断 +a === +b return +a === 0 ? 1 / +a === 1 / b : +a === +b; // 如果 a 为 Number 类型 // 要注意 NaN 这个 special number // NaN 和 NaN 被认为 equal // ================ case &#39;[object Date]&#39;: case &#39;[object Boolean]&#39;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; // Date 和 Boolean 可以看做一类 // 如果 obj 为 Date 或者 Boolean // 那么 +obj 会将 obj 转为 Number 类型 // 然后比较即可 // +new Date() 是当前时间距离 1970 年 1 月 1 日 0 点的毫秒数 // +true =&gt; 1 // +new Boolean(false) =&gt; 0 &#125; // 判断 a 是否是数组 var areArrays = className === &#39;[object Array]&#39;; // 如果 a 不是数组类型 if (!areArrays) &#123; // 如果 a 不是 object 或者 b 不是 object // 则返回 false if (typeof a != &#39;object&#39; || typeof b != &#39;object&#39;) return false; // 通过上个步骤的 if 过滤 // !!保证到此的 a 和 b 均为对象!! // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. // 通过构造函数来判断 a 和 b 是否相同 // 但是，如果 a 和 b 的构造函数不同 // 也并不一定 a 和 b 就是 unequal // 比如 a 和 b 在不同的 iframes 中！ // aCtor instanceof aCtor 这步有点不大理解，啥用？ var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; (&#39;constructor&#39; in a &amp;&amp; &#39;constructor&#39; in b)) &#123; return false; &#125; &#125; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It&#39;s done here since we only need them for objects and arrays comparison. // 第一次调用 eq() 函数，没有传入 aStack 和 bStack 参数 // 之后递归调用都会传入这两个参数 aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. // 将嵌套的对象和数组展开 // 如果 a 是数组 // 因为嵌套，所以需要展开深度比较 if (areArrays) &#123; // Compare array lengths to determine if a deep comparison is necessary. // 根据 length 判断是否应该继续递归对比 length = a.length; // 如果 a 和 b length 属性大小不同 // 那么显然 a 和 b 不同 // return false 不用继续比较了 if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) &#123; // 递归 if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // 如果 a 不是数组 // 进入这个判断分支 // Deep compare objects. // 两个对象的深度比较 var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. // a 和 b 对象的键数量不同 // 那还比较毛？ if (_.keys(b).length !== length) return false; while (length--) &#123; // Deep compare each member // 递归比较 key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // Remove the first object from the stack of traversed objects. // 与 aStack.push(a) 对应 // 此时 aStack 栈顶元素正是 a // 而代码走到此步 // a 和 b isEqual 确认 // 所以 a，b 两个元素可以出栈 aStack.pop(); bStack.pop(); // 深度搜索递归比较完毕 // 放心地 return true return true; &#125;; ​ ``` isNaN ====&gt; _.isNaN(new Number(0)) =&gt; true 实用功能 noConflict: 把 “_” 变量的控制权预留给它原有的所有者. 返回一个引用给 Underscore 对象 identity: 返回与传入参数相等的值. 相当于数学里的: f(x) = x times: 执行某函数n次 escape,unescape:转义HTML字符串，反转到HTML字符串 console.log(_.escape(&#39;Curly, Larry &amp; Moe&#39;)); =&gt; Curly, Larry &amp;amp; Moe console.log(_.unescape(&#39;Curly, Larry &amp;amp; Moe&#39;)); =&gt; Curly, Larry &amp; Moe ​ ​ ​ 链式 chain: 返回一个封装的对象。在封装的对象上调用方法会返回封装的对象本身，直到value()方法调用为止。 var stooges = [&#123;name : &#39;curly&#39;, age : 25&#125;, &#123;name : &#39;moe&#39;, age : 21&#125;, &#123;name : &#39;larry&#39;, age : 23&#125;]; var youngest = _.chain(stooges) .sortBy(function(stooge)&#123; return stooge.age; &#125;) .map(function(stooge)&#123; return stooge.name + &#39; is &#39; + stooge.age; &#125;) .first() .value(); console.log(youngest); =&gt; moe is 21 ​ 可能不是很需要underscore 数组Iterate Underscore _.each(array, iteratee) ES5.1 array.forEach(iteratee) Map Underscore _.map(array, iteratee) ES5.1 array.map(iteratee) Use a function to accumulate a single value from an array (left-to-right) Underscore _.reduce(array, iteratee, memo) ES5.1 array.reduce(iteratee, memo) Use a function to accumulate a single value from an array (right-to-left) Underscore _.reduceRight(array, iteratee, memo) ES5.1 array.reduceRight(iteratee, memo) Test whether all elements in an array pass a predicate Underscore _.every(array, predicate) ES5.1 array.every(predicate) Test whether some element in an array passes a predicate Underscore _.some(array, predicate) ES5.1 array.some(predicate) Find a value in an array Underscore _.find(array, predicate) ES2015 array.find(predicate) Get a property from each element in an array Underscore _.pluck(array, propertyName) ES2015 array.map(value =&gt; value[propertyName]) Check if array includes an element Underscore _.includes(array, element) ES2016 array.includes(element) Convert an array-like object to array Underscore _.toArray(arguments) ES2015 [...arguments] Convert an array of keys and values to an object Underscore _.object(array) ES2015 array.reduce((result, [key, val]) =&gt; Object.assign(result, &#123;[key]: val&#125;), &#123;&#125;) Object Rest/Spread (Stage 2) array.reduce((result, [key, val]) =&gt; &#123;...result, [key]: val&#125;, &#123;&#125;) Create a copy of an array with all falsy values removed Underscore _.compact(array) ES5.1 array.filter(Boolean) ES2015 array.filter(x =&gt; !!x) Create a copy of an array with duplicates removed Underscore _.uniq(array) ES2015 [...new Set(array)] Find the index of a value in an array Underscore _.indexOf(array, value) ES5.1 array.indexOf(value) Find the index in an array by predicate Underscore _.findIndex([4, 6, 7, 12], isPrime); ES2015 [4, 6, 7, 12].findIndex(isPrime); Create an array with n numbers, starting from x Underscore _.range(x, x + n) ES2015 Array.from(Array(n), (_, i) =&gt; x + i) ObjectsNames of own enumerable properties as an array Underscore _.keys(object) ES5.1 Object.keys(object) Number of keys in an object Underscore _.size(object) ES5.1 Object.keys(object).length Names of all enumerable properties as an array Underscore _.allKeys(object) ES2015 [...Reflect.enumerate(object)] Values Underscore _.values(object) ES2015 Object.keys(object).map(key =&gt; object[key]) Create a new object with the given prototype and properties Underscore _.create(proto, properties) ES2015 Object.assign(Object.create(proto), properties) Create a new object from merged own properties Underscore _.assign(&#123;&#125;, source, &#123; a: false &#125;) ES2015 Object.assign(&#123;&#125;, source, &#123; a: false &#125;) Object Rest/Spread (Stage 2) &#123; ...source, a: false &#125; Create a shallow clone of own properties of an object Underscore _.extendOwn(&#123;&#125;, object) Object Rest/Spread (Stage 2) &#123; ...object &#125; Check if an object is an array Underscore _.isArray(object) ES5.1 Array.isArray(object) Check if an object is a finite Number Underscore _.isNumber(object) &amp;&amp; _.isFinite(object) ES2015 Number.isFinite(object) FunctionsBind a function to an object Underscore foo(_.bind(function () &#123; this.bar(); &#125;, this)); foo(_.bind(object.fun, object)); ES2015 foo(() =&gt; &#123; this.bar(); &#125;); foo(() =&gt; object.fun()); UtilityIdentity function Underscore _.identity ES2015 value =&gt; value A function that returns a value Underscore _.constant(value) ES2015 () =&gt; value The empty function Underscore _.noop ES2015 () =&gt; &#123;&#125; Get the current time in milliseconds since the epoch Underscore _.now() ES5.1 Date.now() Template Underscore var greeting = _.template(&quot;hello &lt;%= name %&gt;&quot;); greeting(&#123; name: &#39;moe&#39; &#125;); ES2015 const greeting = (&#123; name &#125;) =&gt; `hello $&#123;name&#125;`; greeting(&#123; name: &#39;moe&#39; &#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Learning summary","slug":"Learning-summary","permalink":"http://lo-que.github.io/tags/Learning-summary/"}]},{"title":"真正的Picking up","slug":"真正的Picking-up","date":"2018-01-05T13:46:35.000Z","updated":"2021-03-28T08:20:06.000Z","comments":true,"path":"2018/01/05/真正的Picking-up/","link":"","permalink":"http://lo-que.github.io/2018/01/05/%E7%9C%9F%E6%AD%A3%E7%9A%84Picking-up/","excerpt":"","text":"今天是来火币的第4天，遇到一很有意思的问题。[华哥]葛大爷是我们组一大牛，调试代码的时候我正好路过，由此知晓了一个U+200B的无宽度空格，这玩意儿导致葛爷代码疯狂报错，全局删除之后，整个世界都清净了。嗯，全角空格\\u3000，半角空格\\u0020。","categories":[{"name":"picking up","slug":"picking-up","permalink":"http://lo-que.github.io/categories/picking-up/"}],"tags":[{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"}]},{"title":"圣杯布局与双飞燕布局","slug":"圣杯布局与双飞燕布局","date":"2017-11-11T12:10:58.000Z","updated":"2018-04-25T07:35:00.000Z","comments":true,"path":"2017/11/11/圣杯布局与双飞燕布局/","link":"","permalink":"http://lo-que.github.io/2017/11/11/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8F%8C%E9%A3%9E%E7%87%95%E5%B8%83%E5%B1%80/","excerpt":"","text":"圣杯布局固比固布局 圣杯布局的出现是来自于a list part上的一篇文章In Search of the Holy Grail。比起双飞翼布局，它的起源不是源于对页面的形象表达。在西方，圣杯是表达“渴求之物”的意思。而双飞翼布局则是源于淘宝的UED，可以说是灵感来自于页面渲染。 通过缩放页面可以发现，随着页面的宽度的变化，这三栏布局是中间盒子优先渲染，两边的盒子框子固定不变，即使页面宽度变小，也不影响我们的浏览。注意：当你缩放页面的时候，宽度不能小于700PX，为了安全起见，最好还是给body加一个最小宽度! &lt;header&gt;&lt;h4&gt;Header内容区&lt;/h4&gt;&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;h4&gt;中间弹性区&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;h4&gt;左边栏&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;h4&gt;右边栏&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;h4&gt;Footer内容区&lt;/h4&gt;&lt;/footer&gt; 此时一定要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染嘛~并且设置其自适应，也就是width:100%。 header &#123; width: 100%; height: 40px; background-color: darkseagreen; &#125; .container &#123; height:200px; overflow:hidden; &#125; .middle &#123; width: 100%; height: 200px; background-color: deeppink; float:left; &#125; .left &#123; width: 200px; height: 200px; background-color: blue; float:left; &#125; .right &#123; width: 200px; height: 200px; background-color: darkorchid; float:left; &#125; footer &#123; width: 100%; height: 30px; background-color: darkslategray; &#125; 此时，三栏并没有在父元素的一行显示，就是因为中间盒子我们给了百分之百的宽度。所有左右两个盒子才会被挤下来。那么如何让它们呈现出一行三列的效果呢？那就要让左边的盒子要到中间盒子的最左边，右边的盒子到中间盒子的最右边。换个想法，如果中间盒子不是100%的宽度，那么按照文档流，左边的盒子一定会在中间盒子的后面显示，接着显示右边的盒子。但是现在中间盒子是满屏了的，所以左右两个盒子被挤到下一行显示。我们要做到的是让左右两个盒子都上去。可以使用CSS的负边距(negative margin)。 让左边的盒子上去 需要设置其左边距为负的中间盒子的宽度，也就是.left &#123;margin-left:-100%;&#125;。这样左盒子才可以往最左边移动。 让右边的盒子上去 需要设置其左边距为负的自己的宽度，也就是.right &#123;margin-left：-200px;&#125;。这样右盒子才可以在一行的最右边显示出自己。 此时，我们初步实现了效果，然而我们的工作才刚刚开始。此时的中间盒子是自适应的宽度，所以中间盒子的内容会被左边的盒子给覆盖掉一部分。 首先:利用父级元素设置左右内边距的值，把父级的三个子盒子往中间挤。.container&#123;padding:0 200px;&#125;这里的200px就是我们想要设置的左右盒子的宽度，此时先预留好。 最后.left&#123; position: relative; left: -200px;&#125;.right&#123;position: relative;right: -210px; 其实还有另外的解决方案.middle&#123;padding-right:200px;padding-left:200px;box-sizing:border-box;&#125;但是这种方案对以后的发展不利，限制了以后可能的使用场景。 还有.middle &#123;width: calc(100% - 400px);margin: 0 auto;&#125;不过这种写法职能兼容IE9及以上版本，而且性能不是很好。 双飞翼布局圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4）","categories":[{"name":"css","slug":"css","permalink":"http://lo-que.github.io/categories/css/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"modules.exports与exports","slug":"modules-exports与exports","date":"2017-10-24T13:15:57.000Z","updated":"2018-04-25T07:36:48.000Z","comments":true,"path":"2017/10/24/modules-exports与exports/","link":"","permalink":"http://lo-que.github.io/2017/10/24/modules-exports%E4%B8%8Eexports/","excerpt":"","text":"1. module.exports 初始值为一个空对象 &#123;&#125; 2. exports 是指向的 module.exports 的引用 3. require() 返回的是 module.exports 而不是 exports","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"data chunk","slug":"data-chunk","date":"2017-10-24T08:57:24.000Z","updated":"2018-04-25T07:35:44.000Z","comments":true,"path":"2017/10/24/data-chunk/","link":"","permalink":"http://lo-que.github.io/2017/10/24/data-chunk/","excerpt":"","text":"首先 组装chunk var data = &quot;&quot; res .on(&#39;data&#39;, function (chunk) &#123; data += chunk &#125;) .on(&quot;end&quot;, function () &#123; //对data转码 &#125;) 但是 当我们调用的时候就会发现 var testIconv = new Iconv(&#39;GBK&#39;, &#39;UTF-8&#39;) testIconv.convert(data).toString() 会抛出EILSEQ异常 仔细查看会发现两个chunk（Buffer对象）的拼接并不正常，相当于进行了buffer.toString() + buffer.toString()。如果buffer不是完整的，则toString出来后的string是存在问题的（比如一个中文字被截断）。这样出来的string就无法被正常转码。 所以应该这样拼接 var chunks = [] var size = 0 res .on(&#39;data&#39;, function (chunk) &#123; chunks.push(chunk) size += chunk.length &#125;) .on(&#39;end&#39;, function () &#123; var data = null switch(chunks.length) &#123; case 0: data = new Buffer(0) break case 1: data = chunks[0] break default: data = new Buffer(size); for (var i = 0, pos = 0, l = chunks.length; i &lt; l; i++) &#123; var chunk = chunks[i] chunk.copy(data, pos) pos += chunk.length &#125; break &#125; &#125;) 对其进行封装重构 var BufferHelper = function () &#123; this.buffers = [] this.size = 0 this._status = &quot;changed&quot; &#125; BufferHelper.prototype.concat = function (buffer) &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; this._concat(arguments[i]) &#125; return this &#125; BufferHelper.prototype._concat = function (buffer) &#123; this.buffers.push(buffer) this.size = this.size + buffer.length this._status = &quot;changed&quot; return this &#125; BufferHelper.prototype._toBuffer = function () &#123; var data = null var buffers = this.buffers switch(buffers.length) &#123; case 0: data = new Buffer(0) break case 1: data = buffers[0] break default: data = new Buffer(this.size) for (var i = 0, pos = 0, l = buffers.length; i &lt; l; i++) &#123; var buffer = buffers[i] buffer.copy(data, pos) pos += buffer.length &#125; break &#125; // Cache the computed result this._status = &quot;computed&quot; this.buffer = data return data &#125; BufferHelper.prototype.toBuffer = function () &#123; return this._status === &quot;computed&quot; ? this.buffer : this._toBuffer() &#125; BufferHelper.prototype.toString = function () &#123; return Buffer.prototype.toString.apply(this.toBuffer(), arguments) &#125; module.exports = BufferHelper 这里有两个私有方法，_concat和_toBuffer。其目的是保证每个方法的职责单一，还在toBuffer里做了一下状态设置，使得不浪费CPU。接下来的调用就非常简单了。 var http = require(&#39;http&#39;) var BufferHelper = require(&#39;bufferhelper&#39;) http.createServer(function (request, response) &#123; var bufferHelper = new BufferHelper() request.on(&quot;data&quot;, function (chunk) &#123; bufferHelper.concat(chunk) &#125;) request.on(&#39;end&#39;, function () &#123; var html = bufferHelper.toBuffer().toString() response.writeHead(200) response.end(html) &#125;) &#125;).listen(8001) 最后，node-iconv的作者提供了一个工具集node-iconv 以上是朴灵大大很久前发表在cnodejs.org上的文章, 现在可以把chunk push进临时数组, 之后concat拼接下, 代码如下 dataArray.push(chunk) Buffer.concat(dataArray).toString(‘base64’)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://lo-que.github.io/categories/nodejs/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"html语义化","slug":"html语义化","date":"2017-08-19T13:20:41.000Z","updated":"2018-04-25T07:36:28.000Z","comments":true,"path":"2017/08/19/html语义化/","link":"","permalink":"http://lo-que.github.io/2017/08/19/html%E8%AF%AD%E4%B9%89%E5%8C%96/","excerpt":"","text":"Learnning Notehtml语义化 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置; 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来;","categories":[{"name":"html","slug":"html","permalink":"http://lo-que.github.io/categories/html/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"extends","slug":"extends","date":"2017-08-16T13:12:35.000Z","updated":"2018-04-25T07:36:04.000Z","comments":true,"path":"2017/08/16/extends/","link":"","permalink":"http://lo-que.github.io/2017/08/16/extends/","excerpt":"","text":"Learnning Noteextends理解extends block 拓展调用 在本文件中（使用extengds的文件中）调用 block content 将之后的代码整合为块 实际上在 被extends的文件中 使用 佐证 在被extengds的文件中 更换 block content与block desc的顺序 可证 doctype html &lt;!--[if IE 8]&gt;&lt;html class=&#39;ie8&#39;&gt;&lt;![endif]--&gt; &lt;!--[if IE 9]&gt;&lt;html class=&#39;ie9&#39;&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;html&gt;&lt;!--&lt;![endif]--&gt; head meta(charset=&#39;utf8&#39;) - var course = &#39;jade&#39; title #&#123;course.toUpperCase()&#125; body block content block desc p 测试 &lt;/html&gt; index.jade 实际上在指向layout.jade var index = layout include才是引用 在本文件中使用被include的文件中的代码","categories":[{"name":"jade","slug":"jade","permalink":"http://lo-que.github.io/categories/jade/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"async && defer","slug":"async-defer","date":"2017-06-18T13:05:37.000Z","updated":"2021-11-24T03:00:47.635Z","comments":true,"path":"2017/06/18/async-defer/","link":"","permalink":"http://lo-que.github.io/2017/06/18/async-defer/","excerpt":"","text":"Learnning Noteasync defer查阅资料 &lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics 自己理解 默认引用 script:&lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。 async模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。 defer模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"XMLHttpRequest","slug":"XMLHttpRequest","date":"2017-06-10T03:01:34.000Z","updated":"2018-04-25T07:37:01.000Z","comments":true,"path":"2017/06/10/XMLHttpRequest/","link":"","permalink":"http://lo-que.github.io/2017/06/10/XMLHttpRequest/","excerpt":"","text":"0 (未初始化)： (XMLHttpRequest)对象已经创建，但还没有调用open()方法。1 (载入)：已经调用open() 方法，但尚未发送请求。2 (载入完成)： 请求已经发送完成。3 (交互)：可以接收到部分响应数据。4 (完成)：已经接收到了全部数据，并且连接已经关闭。","categories":[{"name":"network","slug":"network","permalink":"http://lo-que.github.io/categories/network/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"从输入Url到页面加载完成之间都发生了什么事","slug":"从输入Url到页面加载完成之间都发生了什么事","date":"2017-04-19T11:20:27.000Z","updated":"2018-04-25T07:33:44.000Z","comments":true,"path":"2017/04/19/从输入Url到页面加载完成之间都发生了什么事/","link":"","permalink":"http://lo-que.github.io/2017/04/19/%E4%BB%8E%E8%BE%93%E5%85%A5Url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E4%B9%8B%E9%97%B4%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B/","excerpt":"","text":"Learnning Note从输入Url到页面加载完成之间都发生了什么事 chrome搜索自身的dns缓存 搜索操作系统自身的dns缓存（浏览器没有找抖缓存或缓存已经失效） 读取本地的HOST文件 浏览器发起一个dns的系统调用 宽带运营商服务器查看本身缓存 运营商服务器发起一个迭代dns解析的请求 运营商-根域-com域的顶级域-com域（域名的注册商提供） 运营商服务器吧结果返回操作系统内核同时缓存起来 操作系统内核把结果返回浏览器 最终由浏览器拿到 浏览器获得域名对应的ip地址后，发起HTTP三次握手 tcp／ip连接建立起来后，浏览器就可以向服务器发送HTTP请求了 服务器端接受到了这个请求，根据路径参数，经过后段的一些处理之后，把处理后的一个结果的数据返回给浏览器html 浏览器拿到html 剩下的css js 图片之类的资源都要经过以上7步 浏览器根据拿到的资源对画面进行渲染 请求和响应 都会发送http头和正文信息 google一下发现大神文章从输入url到页面加载完成之间都发生了什么 更简洁的理解 浏览器检查缓存，如果请求的对象缓存是新的，跳到# 9 浏览器询问操作系统服务器的IP地址 操作系统进行DNS查找并将IP地址回复到浏览器 浏览器打开一个TCP连接到服务器（这一步要复杂得多） 浏览器通过TCP连接发送HTTP请求 浏览器接收HTTP响应，并可能关闭TCP连接，或为另一个请求重用它。 浏览器检查响应是否是一个重定向或条件反应（3xx结果状态码），授权请求（401），错误（4xx和5XX），等等；这些不同于正常的反应处理（2xx） 如果缓存，响应存储在高速缓存 浏览器解码响应（不考虑gzip压缩） 浏览器决定如何处理响应（例如它是一个HTML页面，它是一个图像，它是一个声音剪辑吗？） 浏览器呈现响应，或提供未识别类型的下载对话框。 此外，还有很多其他的事情发生在平行于这个（地址，输入处理投机性预取，增加网页浏览历史，用户，显示进度通知插件和扩展，渲染页面的同时它的下载，流水线，为保持活着，检查恶意内容等跟踪连接）和整个操作得到的幅度更复杂的命令（HTTPS证书和密码以及ssl pining)","categories":[{"name":"network","slug":"network","permalink":"http://lo-que.github.io/categories/network/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"浏览器不兼容h5","slug":"浏览器不兼容h5","date":"2017-04-16T11:23:38.000Z","updated":"2021-11-24T02:57:55.535Z","comments":true,"path":"2017/04/16/浏览器不兼容h5/","link":"","permalink":"http://lo-que.github.io/2017/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E5%85%BC%E5%AE%B9h5/","excerpt":"","text":"在进行毕业设计的过程中 遇见了浏览器不兼容h5的问题第一种方法：IE9以下版本的IE将创建HTML5标签， 非IE浏览器会忽略这段代码，因此不会发生http请求，也就不影响网页执行效率 &lt;!--[if lt IE9]&gt; &lt;script&gt; (function() &#123; if (! /*@cc_on!@*/ 0) return; var e = &quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;.split(&#39;, &#39;); var i= e.length; while (i--)&#123; document.createElement(e[i]) &#125; &#125;)() &lt;/script&gt; &lt;![endif]--&gt; 第二种方法：在你的网页中引入Google的html5shiv包（推荐） &lt;!--[if lt IE9]&gt; &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局 /*html5*/ article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125; 但是如果ie6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢? 我们可以参照facebook的做法，即引导用户进入带有noscript标识的 “/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。 &lt;!--[if lte IE 8]&gt; &lt;noscript&gt; &lt;style&gt;.html5-wrappers&#123;display:none!important;&#125;&lt;/style&gt; &lt;div class=&quot;ie-noscript-warning&quot;&gt;您的浏览器禁用了脚本，请&lt;a href=&quot;&quot;&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href=&quot;/?noscript=1&quot;&gt;继续访问&lt;/a&gt;. &lt;/div&gt; &lt;/noscript&gt; &lt;![endif]--&gt; 引导用户开启脚本,或者直接跳转到HTML4标签设计的界面。 其他： Dean Edwards的IE7.js (以及 IE8.js, IE9.js) 这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。 Aaron Gustafson的 eCSStender 此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。 Drew Diller的 DD_roundies 这是一个基于IE VML实现一些CSS3效果的。 Remiz Rahnas的border-radius.htc 此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。 Nick Fetchak的 ie-css3.htc 关于此方法，我在前面的”让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。 Keith Clark的ie-css3.js 这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。 zoltandulac的cssSandpaper 这是一个使用IE滤镜实现一些CSS3属性的方法。 css3pie的css3 PIE.htc 支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。 下面对第8第方法的做一下简单介绍： 官方网站：http://css3pie.com/ 使用方法： 第一步：下载css3 PIE.htc 文件 第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。 第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段： #id &#123; border: 1px solid #999; -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px; behavior: url(path/to/PIE.htc); &#125; 注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。 已知的一些问题： 此方法并不是万能的，也有一些局限性和需要注意的地方。 z-index相关问题 IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素 position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。 所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器 下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并 赋予一个z-index值（不可为-1）。 相当路径的问题 IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目 录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border- image后面的URL属性路径也不好处理。 缩写的问题 使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。 提供正确的Content-Type 要想让IE浏览器支持htc文件，需要一个有着”text/x-component” 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。 如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理：AddType text/x-component .htc 但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下： &lt;?php header( &#39;Content-type: text/x-component&#39; ); include( &#39;pie.htc&#39; ); ?&gt; 通过PHP文件来增加一个含有”text/x-component”字样的Content-type头，同时调用pie.htc文件。 关于上面所示的php文件，您可以狠狠地点击这里：pie.php(右键 – [目标|链接另存为])，或者您可以直接新建一个php文件，把上面的两行代码复制进去。或者在本文提供的原始打包资源的wrappers文件夹里面也有此php文件，不过名称是大写的。 如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是： behavior: url(pie.php);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"什么是SSL Pining","slug":"什么是SSL-Pining","date":"2017-04-04T14:53:54.000Z","updated":"2018-04-25T07:34:48.000Z","comments":true,"path":"2017/04/04/什么是SSL-Pining/","link":"","permalink":"http://lo-que.github.io/2017/04/04/%E4%BB%80%E4%B9%88%E6%98%AFSSL-Pining/","excerpt":"","text":"SSL(Secure Socket Layer 安全套接字层)确保客户端-服务器在HTTP请求的方式上将通讯内容加密—-被指定为HTTPS(SSL上的HTTP)。这种加密体系是基于PKI(Pbulic Key Infrastructure,公钥体系)和(Session key,会话key)。其中Session key 被引进的原因是对于公钥/私钥的加密和解密会消耗处理能力，会是整个交流进程速度变慢。 SSL 安全—鉴定 SSL安全是基于证书的信任链。当一个通信开始的时候，客户端检查服务器的SSL证书，检查这个证书是否被信用根CA机构或者其他用户信任结构所信任。 尽管SSL通信被认为是一个非常安全的和坚不可摧的，但是中间人攻击依然还是真实存在的威胁，它可以用好几种方法去实现，例如ARP 缓存中毒、DNS 欺骗等。 对于ARP缓存中毒，可以简单理解为中间人通过地址解析协议的IP映射到设备的Mac地址这一特性进行攻击。例如，我们用一下三个角色来描述一个简单的网络： 一个普通的用户设备U 攻击者的设备A 路由器R 攻击者的设备A可以发送一个ARP依赖包给用户设备U，把他自己伪装成路由器R。为了完成中间人攻击，A发送另一个ARP依赖给R，告诉路由器它就是U。这样的话，A就成了U和R沟通的中间者，A就可以窃听和拦截信息。IP转发经常被用于攻击者在用户设备和路由器的无缝交流。也就是说通过IP转发，攻击者可以窃取和监听，但是用户和路由器是无感知的。 DNS欺骗主要在于攻击者破话服务器的域名映射。攻击者尝试强迫DNS去返回一个不正确的地址，而这个地址就是攻击者的计算机地址。 SSL pinning https协议验证服务器身份的方式通常有三种，一是根据浏览器或者说操作系统自带的证书链；二是使用自签名证书；三是自签名证书加上SSL Pinning特性。第一种需要到知名证书机构购买证书，需要一定预算。第二种多见于内网使用。第三种在是安全性最高的，但是需要浏览器插件或客户端使用了SSL Pinning特性。 所以SSL Pinning，即SSL证书绑定，是验证服务器身份的一种方式，是在https协议建立通信时增加的代码逻辑，它通过自己的方式验证服务器身份，然后决定通信是否继续下去。它唯一指定了服务器的身份，所以安全性较高。 我们使用SSL pinning来确保app通信仅仅发生在指定的服务器上。其中的先决条件就是价格目标服务器的SSL证书放到app里面。这个证书被用于会话配置。","categories":[{"name":"network","slug":"network","permalink":"http://lo-que.github.io/categories/network/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"call && apply","slug":"call-apply","date":"2017-01-13T12:11:26.000Z","updated":"2018-04-25T07:35:21.000Z","comments":true,"path":"2017/01/13/call-apply/","link":"","permalink":"http://lo-que.github.io/2017/01/13/call-apply/","excerpt":"","text":"call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 function add(a,b) &#123; this(a,b) alert(a+b) &#125; function sub(a,b) &#123; alert(a-b) &#125; add.call(sub,3,1)//2,4 add.call(sub,3,1)将add执行的上下文由window切换为sub，即this指向是从window变为sub。 首先 add.call(sub,3,1)执行的是 add方法， 然后，add执行的时候，this已经变成了 sub这个方法本身，所以this(a,b)这一句弹出了2。 function Animal(name)&#123; this.name = name this.showName = function()&#123; alert(this.name) &#125; &#125; function Cat(name)&#123; Animal.call(this, name) &#125; var cat = new Cat(&quot;Black Cat&quot;) cat.showName() 首先执行var cat = new Cat(“Black Cat”)进入function Cat(name){ function Cat(name)&#123; Animal.call(this, name) &#125; 这时候的this为Cat{}对象，并非Animal，再接执行 function Animal(name)&#123; this.name = name this.showName = function()&#123; alert(this.name) &#125; &#125; 此时的this对象绑定为Cat{},因此是Cat对象获得了两个属性为： Cat&#123;name: &quot;Black Cat&quot;,showName:function() &#123; alert(this.name) &#125;&#125;， 回到 var cat = Cat&#123; name:&quot;Black Cat&quot;, showName:function() &#123; alert(this.name) &#125;&#125; 最后才是cat.showName()","categories":[{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"}],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]}],"categories":[{"name":"http","slug":"http","permalink":"http://lo-que.github.io/categories/http/"},{"name":"javascript","slug":"javascript","permalink":"http://lo-que.github.io/categories/javascript/"},{"name":"picking up","slug":"picking-up","permalink":"http://lo-que.github.io/categories/picking-up/"},{"name":"Computer basis","slug":"Computer-basis","permalink":"http://lo-que.github.io/categories/Computer-basis/"},{"name":"css","slug":"css","permalink":"http://lo-que.github.io/categories/css/"},{"name":"network","slug":"network","permalink":"http://lo-que.github.io/categories/network/"},{"name":"nodejs","slug":"nodejs","permalink":"http://lo-que.github.io/categories/nodejs/"},{"name":"html","slug":"html","permalink":"http://lo-que.github.io/categories/html/"},{"name":"jade","slug":"jade","permalink":"http://lo-que.github.io/categories/jade/"}],"tags":[{"name":"http","slug":"http","permalink":"http://lo-que.github.io/tags/http/"},{"name":"vue diff, react diff","slug":"vue-diff-react-diff","permalink":"http://lo-que.github.io/tags/vue-diff-react-diff/"},{"name":"GC VO AO CalleeStack","slug":"GC-VO-AO-CalleeStack","permalink":"http://lo-que.github.io/tags/GC-VO-AO-CalleeStack/"},{"name":"性能优化","slug":"性能优化","permalink":"http://lo-que.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Picking up","slug":"Picking-up","permalink":"http://lo-que.github.io/tags/Picking-up/"},{"name":"Math","slug":"Math","permalink":"http://lo-que.github.io/tags/Math/"},{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"},{"name":"Learning summary","slug":"Learning-summary","permalink":"http://lo-que.github.io/tags/Learning-summary/"}]}