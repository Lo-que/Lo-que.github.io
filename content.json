{"meta":{"title":"Blog","subtitle":"Blog","description":"qudongqi's personal blog","author":"屈东奇","url":"http://lo-que.github.io"},"pages":[],"posts":[{"title":"css 命名规范","slug":"css-命名规范","date":"2018-01-24T03:17:11.000Z","updated":"2018-04-24T14:29:19.000Z","comments":true,"path":"2018/01/24/css-命名规范/","link":"","permalink":"http://lo-que.github.io/2018/01/24/css-命名规范/","excerpt":"","text":"Learnning Notecss命名规范base头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签页：tab 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：register 状态：status 投票：vote 合作伙伴：partner 注释/ Header / 内容区 / End Header / id的命名:(1)页面结构容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center (2)导航导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary (3)功能标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop（如购物车） 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guide 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class命名(1)颜色:使用颜色的名称或者16进制代码,如.red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } (2)字体大小,直接使用”font+字体大小”作为名称,如.font10px { font-size: 10px; } .font6pt {font-size: 6pt; } (3)对齐样式,使用对齐目标的英文名称,如.left { float:left; } .bottom { float:bottom; } (4)标题栏样式,使用”类别+功能”的方式命名,如.barnews { } .barproduct { } 注意事项: 1. 一律小写; 2. 尽量用英文; 3. 不加中杠和下划线; 4. 尽量不缩写； class 名称中只能出现小写字符和连字符（不是下划线，也不是驼峰命名法）。连字符应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 样式命名1） 主要的 master.css布局，版面 layout.css专栏 columns.css文字 font.css打印样式 print.css主题 themes.css 2）reset.css // 对浏览器的默认样式进行重设layout.css // 管理页面的布局typeset.css // 图文的编排color.css // 统一管理颜色的搭配print.css // 打印效果样式ie.css // 把对ie的hack单独分开 3）reset.cssheader.css // 头部的所有样式container.css // 除头部/底部外的中间区域样式footer.css // 底部样式print.cssie.css 4）reset.css / 页面样式重置 /header.css / 全站头部样式 /footer.css / 全站尾部样式 /public.css / 全站公共模块样式 /index.css / 首页特有样式 /container.css / 二级及以下主体样式 /print.css / 打印样式 /ie.css / IE hack /","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"underscore学习小结","slug":"underscore学习小结","date":"2018-01-22T12:38:34.000Z","updated":"2018-04-24T10:41:21.000Z","comments":true,"path":"2018/01/22/underscore学习小结/","link":"","permalink":"http://lo-que.github.io/2018/01/22/underscore学习小结/","excerpt":"","text":"underscore.jsUnderscore.js 是一个由Jeremy Ashkenas开发的JavaScript库，提供了许多作为开发者在开发Web项目时所需要的实用功能。 代码变得更加易读： _.isEmpty({}) //true 代码更容易编写： _.flatten([[0, 1], [2, 3], [4, 5]]) // [0, 1, 2, 3, 4, 5] 提供了原生没有的方法： _.range(5) //[0, 1, 2, 3, 4] 甚至可以作为模版引擎： _.template(&#39;&lt;p&gt;&lt;%= text %&gt;&lt;/p&gt;&#39;, {text: &#39;SitePoint Rocks!&#39;}) // &lt;p&gt;SitePoint Rocks!&lt;/p&gt; USA Today 今日美国 LinkedIn 领英 Khan Academy 可汗学院 集合：数组或对象 each 对集合循环操作，只针对function //遍历数组或者对象的每个元素 // 第一个参数为数组（包括类数组）或者对象 // 第二个参数为迭代方法，对数组或者对象每个元素都执行该方法 // 该方法又能传入三个参数，分别为 (item, index, array)（(value, key, obj) for object） // 与 ES5 中 Array.prototype.forEach 方法传参格式一致 // 第三个参数（可省略）确定第二个参数 iteratee 函数中的（可能有的）this 指向 // 即 iteratee 中出现的（如果有）所有 this 都指向 context // notice: _.each 方法不能用 return 跳出循环（同样，Array.prototype.forEach 也不行） _.each([1, 2, 3], function (ele, idx) { console.log(idx + &quot;:&quot; + ele); }); =&gt; 0:1 1:2 2:3 map 对集合以map方式进行遍历，返回一个新数组 iteratee 可以是对象或字符串 console.log( _.map([1, 2, 3], function(num){ return num * 3; }) ); =&gt; [3, 6, 9] reduce: 按callback缩减集合 console.log( _.reduce([1, 2, 3], function (memo, num) { return memo + num; }, 0) ); =&gt; 6 filter: 过滤器 _.find = _.detect 返回第一个 console.log( _.filter([1, 2, 3, 4, 5, 6], function(num){ return num &amp; 1 == 0; }) ); =&gt; [ 2, 4, 6 ] reject: 过滤不符合要求的 console.log( _.reject([1, 2, 3, 4, 5, 6], function(num){ return num &amp; 1 == 0; }) ); =&gt; [ 1, 3, 5 ] where: 根据指定键值对 遍历list，返回新的数组。（类似于sql语句中的where）&amp;： find 返回第一个 var list = [ {title:&quot;AAA&quot;,year: 1982}, {title:&quot;BBB&quot;,year: 1900}, {title:&quot;CCC&quot;,year: 1982} ]; console.log( _.where(list,{year: 1982}) ); =&gt; [ { title: &#39;AAA&#39;, year: 1982 }, { title: &#39;CCC&#39;, year: 1982 } ] _.contains = _.includes = _.include: 判断数组或者对象中（value 值）是否有指定元素 every = all 所有满足 返回true some = any 只有有一个满足 返回true invoke: 数组或者对象中的每个元素都调用 method 方法，返回调用后的结果（数组或者关联数组） pluck: 提取一个集合里指定的属性值 var users = [ {name: &#39;moe&#39;, age: 40}, {name: &#39;larry&#39;, age: 50} ]; console.log( _.pluck(users, &#39;name&#39;) ); =&gt; [ &#39;moe&#39;, &#39;larry&#39; ] max,min,sortBy: 取list中的最大，最小元素，自定义比较器 console.log( _.max(users, function (stooge) { return stooge.age; }) ); =&gt; { name: &#39;larry&#39;, age: 50 } var numbers = [10, 5, 100, 2, 1000]; console.log( _.min(numbers) ); =&gt; 2 console.log( _.sortBy([3, 4, 2, 1 , 6], function (num) { return Math.max(num); }) ); =&gt; [ 1, 2, 3, 4, 6 ] ​ groupBy: 把一个集合分组成多个集合 console.log( _.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;) ); =&gt; { &#39;3&#39;: [ &#39;one&#39;, &#39;two&#39; ], &#39;5&#39;: [ &#39;three&#39; ] } countBy: 把一个数据分组后计数 onsole.log( _.countBy([1, 2, 3, 4, 5], function (num) { return num % 2 == 0 ? &#39;even&#39; : &#39;odd&#39;; }) ); =&gt; { odd: 3, even: 2 } toArray: 将list转换成一个数组 console.log( (function () { return _.toArray(arguments).slice(1); })(1, 2, 3, 4) ); =&gt; [ 2, 3, 4 ] size: 得到list中元素个数 console.log( _.size({one: 1, two: 2, three: 3}) ); shuffle 随机打乱 洗牌算法 partition 将数组或者对象中符合条件的元素和不符合条件的元素分别放入两个数组 数组 _.first = _.head = _.take 返回前n个元素 n默认为1 initial 返回出去后n个元素的数组 last 返回后n个元素 rest = tail 返回出去前n个元素 compact 去除数组中所有的假值 false null undefined ‘’ NaN 0 √ flatten 将数组展开 //input =&gt; Array 或者 arguments // shallow =&gt; 是否只展开一层 // strict === true，通常和 shallow === true 配合使用 // 表示只展开一层，但是不保存非数组元素（即无法展开的基础类型） // flatten([[1, 2], 3, 4], true, true) =&gt; [1, 2] // flatten([[1, 2], 3, 4], false, true) = &gt; [] // startIndex =&gt; 从 input 的第几项开始展开 // ===== // // 可以看到，如果 strict 参数为 true，那么 shallow 也为 true // 也就是展开一层，同时把非数组过滤 // [[1, 2], [3, 4], 5, 6] =&gt; [1, 2, 3, 4] var flatten = function(input, shallow, strict, startIndex) { // output 数组保存结果 // 即 flatten 方法返回数据 // idx 为 output 的累计数组下标 var output = [], idx = 0; // 根据 startIndex 变量确定需要展开的起始位置 for (var i = startIndex || 0, length = getLength(input); i &lt; length; i++) { var value = input[i]; // 数组 或者 arguments // 注意 isArrayLike 还包括 {length: 10} 这样的，过滤掉 if (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) { // flatten current level of array or arguments object // (!shallow === true) =&gt; (shallow === false) // 则表示需深度展开 // 继续递归展开 if (!shallow) // flatten 方法返回数组 // 将上面定义的 value 重新赋值 value = flatten(value, shallow, strict); // 递归展开到最后一层（没有嵌套的数组了） // 或者 (shallow === true) =&gt; 只展开一层 // value 值肯定是一个数组 var j = 0, len = value.length; // 这一步貌似没有必要 // 毕竟 JavaScript 的数组会自动扩充 // 但是这样写，感觉比较好，对于元素的 push 过程有个比较清晰的认识 output.length += len; // 将 value 数组的元素添加到 output 数组中 while (j &lt; len) { output[idx++] = value[j++]; } } else if (!strict) { // (!strict === true) =&gt; (strict === false) // 如果是深度展开，即 shallow 参数为 false // 那么当最后 value 不是数组，是基本类型时 // 肯定会走到这个 else-if 判断中 // 而如果此时 strict 为 true，则不能跳到这个分支内部 // 所以 shallow === false 如果和 strict === true 搭配 // 调用 flatten 方法得到的结果永远是空数组 [] output[idx++] = value; } } return output; }; without 从数组中移除指定的元素，返回移除后的数组副本 union,intersection,difference,uniq: 并集，交集，差集，取唯一(去重) zip unzip 合并数组中的元素 是group的反向操作 indexOf,lastIndexOf, 取索引位置 sortedIndex 二分查找 function createIndexFinder(dir, predicateFind, sortedIndex) ​ 函数 bind: this指向不变 bindAll 绑定方法名到对象上, 当这些方法被执行时将在对象的上下文执行. 绑定函数用作事件处理时非常方便, 否则函数调用时 this 关键字根本没什么用 var func = function(greeting){ return greeting + &#39;: &#39; + this.name }; func = _.bind(func, {name : &#39;moe&#39;}, &#39;hi&#39;); console.log(func()); =&gt; hi: moe var buttonView = { label : &#39;underscore&#39;, onClick : function(){ console.log(&#39;clicked: &#39; + this.label); }, onHover : function(){ console.log(&#39;hovering: &#39; + this.label); } }; var func = _.bindAll(buttonView, &#39;onClick&#39;, &#39;onHover&#39;); func.onClick(); =&gt; clicked: underscore ​ partial:在不改变this的情况下，通过参数填充数据 可以使方法设定默认值 柯里化(Currying) var add = function(a, b) { return a + b; }; add5 = _.partial(add, 5); console.log(add5(10)); =&gt; 15 ​ memoize 记忆化，存储中间运算结果，提高效率 // 参数 hasher 是个 function，用来计算 key // 如果传入了 hasher，则用 hasher 来计算 key // 否则用 key 参数直接当 key（即 memoize 方法传入的第一个参数） // _.memoize(function, [hashFunction]) // 适用于需要大量重复求值的场景 // 比如递归求解菲波那切数 var fibonacci = _.memoize(function(n) { return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); }); console.log(fibonacci(10)); =&gt; 55 ​ delay: 延迟触发 setTimeout _.defer = _.partial ( _.delay, _, 1); throttle: 函数节流（如果有连续事件响应，则每间隔一定时间段触发） // 每间隔 wait(Number) milliseconds 触发一次 func 方法 // 如果 options 参数传入 {leading: false} // 那么不会马上触发（等待 wait milliseconds 后第一次触发 func） // 如果 options 参数传入 {trailing: false} // 那么最后一次回调不会被触发 // options 不能同时设置 leading 和 trailing 为 false // 示例： // var throttled = _.throttle(updatePosition, 100); // $(window).scroll(throttled); // 调用方式（注意看 A 和 B console.log 打印的位置）： // _.throttle(function, wait, [options]) // sample 1: _.throttle(function(){}, 1000) // print: A, B, B, B ... // sample 2: _.throttle(function(){}, 1000, {leading: false}) // print: B, B, B, B ... // sample 3: _.throttle(function(){}, 1000, {trailing: false}) // print: A, A, A, A ... debounce: 函数去抖（连续事件触发结束后只触发一次） // sample 1: _.debounce(function(){}, 1000) // 连续事件结束后的 1000ms 后触发 // sample 1: _.debounce(function(){}, 1000, true) // 连续事件触发后立即触发（此时会忽略第二个参数） wrap 以函数作为函数传递，可以增加函数前后的控制 var hello = function(name) { return &quot;hello: &quot; + name; }; hello = _.wrap(hello, function(func) { return &quot;before, &quot; + func(&quot;moe&quot;) + &quot;, after&quot;; }); console.log(hello()); =&gt; before, hello: moe, after ​ compose: 组合函数调用关系，把单独的f(),g(),h()组合成f(g(h())) 对象 // Keys in IE &lt; 9 that won&#39;t be iterated by `for key in ...` and thus missed. // IE &lt; 9 下 不能用 for key in ... 来枚举对象的某些 key // 比如重写了对象的 `toString` 方法，这个 key 值就不能在 IE &lt; 9 下用 for in 枚举到 // IE &lt; 9，{toString: null}.propertyIsEnumerable(&#39;toString&#39;) 返回 false // IE &lt; 9，重写的 `toString` 属性被认为不可枚举 // 据此可以判断是否在 IE &lt; 9 浏览器环境中 var hasEnumBug = !{toString: null}.propertyIsEnumerable(&#39;toString&#39;); // IE &lt; 9 下不能用 for in 来枚举的 key 值集合 //为什么constructor要和nonEnumerableProps区分处理 // 个人觉得可能是 `constructor` 和其他属性不属于一类 // nonEnumerableProps[] 中都是方法 // 而 constructor 表示的是对象的构造函数 // 所以区分开来了 var nonEnumerableProps = [&#39;valueOf&#39;, &#39;isPrototypeOf&#39;, &#39;toString&#39;, &#39;propertyIsEnumerable&#39;, &#39;hasOwnProperty&#39;, &#39;toLocaleString&#39;]; ​ keys,values,paris,invert: 取属性名，取属性值，把对象转换成[key,value]数组，对调键值 var obj = {one: 1, two: 2, three: 3} console.log(_.keys(obj)); console.log(_.values(obj)); console.log(_.pairs(obj)); console.log(_.invert(obj)); =&gt; [ &#39;one&#39;, &#39;two&#39;, &#39;three&#39; ] [ 1, 2, 3 ] [ [ &#39;one&#39;, 1 ], [ &#39;two&#39;, 2 ], [ &#39;three&#39;, 3 ] ] { &#39;1&#39;: &#39;one&#39;, &#39;2&#39;: &#39;two&#39;, &#39;3&#39;: &#39;three&#39; } ​ extend: 复制对象的所有属性到目标对象上，覆盖已有属性 defaults: 复制对象的所有属性到目标对象上，跳过已有属性 console.log( _.extend({name : &#39;moe&#39;}, {age : 50}) ); =&gt; { name: &#39;moe&#39;, age: 50 } var iceCream = {flavor : &quot;chocolate&quot;}; console.log( _.defaults(iceCream, {flavor : &quot;vanilla&quot;, sprinkles : &quot;lots&quot;}) ); =&gt; { flavor: &#39;chocolate&#39;, sprinkles: &#39;lots&#39; } 1. pick,omit: 返回一个对象的副本，保留指定的属性或去掉指定的属性 2. tag: 用对象作为参数来调用函数，作为函数链式调用的一环 3. isEqual: ```javascript // &quot;内部的&quot;/ &quot;递归地&quot;/ &quot;比较&quot; // 该内部方法会被递归调用 var eq = function(a, b, aStack, bStack) { // Identical objects are equal. `0 === -0`, but they aren&#39;t identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). // a === b 时 // 需要注意 `0 === -0` 这个 special case // 0 和 -0 被认为不相同（unequal） // 至于原因可以参考上面的链接 if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. // 如果 a 和 b 有一个为 null（或者 undefined） // 判断 a === b if (a == null || b == null) return a === b; // Unwrap any wrapped objects. // 如果 a 和 b 是 underscore OOP 的对象 // 那么比较 _wrapped 属性值（Unwrap） if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. // 用 Object.prototype.toString.call 方法获取 a 变量类型 var className = toString.call(a); // 如果 a 和 b 类型不相同，则返回 false // 类型都不同了还比较个蛋！ if (className !== toString.call(b)) return false; switch (className) { // Strings, numbers, regular expressions, dates, and booleans are compared by value. // 以上五种类型的元素可以直接根据其 value 值来比较是否相等 case &#39;[object RegExp]&#39;: // RegExps are coerced to strings for comparison (Note: &#39;&#39; + /a/i === &#39;/a/i&#39;) case &#39;[object String]&#39;: // Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is // equivalent to `new String(&quot;5&quot;)`. // 转为 String 类型进行比较 return &#39;&#39; + a === &#39;&#39; + b; // RegExp 和 String 可以看做一类 // 如果 obj 为 RegExp 或者 String 类型 // 那么 &#39;&#39; + obj 会将 obj 强制转为 String // 根据 &#39;&#39; + a === &#39;&#39; + b 即可判断 a 和 b 是否相等 // ================ case &#39;[object Number]&#39;: // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN // 如果 +a !== +a // 那么 a 就是 NaN // 判断 b 是否也是 NaN 即可 if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. // 排除了 NaN 干扰 // 还要考虑 0 的干扰 // 用 +a 将 Number() 形式转为基本类型 // 即 +Number(1) ==&gt; 1 // 0 需要特判 // 如果 a 为 0，判断 1 / +a === 1 / b // 否则判断 +a === +b return +a === 0 ? 1 / +a === 1 / b : +a === +b; // 如果 a 为 Number 类型 // 要注意 NaN 这个 special number // NaN 和 NaN 被认为 equal // ================ case &#39;[object Date]&#39;: case &#39;[object Boolean]&#39;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; // Date 和 Boolean 可以看做一类 // 如果 obj 为 Date 或者 Boolean // 那么 +obj 会将 obj 转为 Number 类型 // 然后比较即可 // +new Date() 是当前时间距离 1970 年 1 月 1 日 0 点的毫秒数 // +true =&gt; 1 // +new Boolean(false) =&gt; 0 } // 判断 a 是否是数组 var areArrays = className === &#39;[object Array]&#39;; // 如果 a 不是数组类型 if (!areArrays) { // 如果 a 不是 object 或者 b 不是 object // 则返回 false if (typeof a != &#39;object&#39; || typeof b != &#39;object&#39;) return false; // 通过上个步骤的 if 过滤 // !!保证到此的 a 和 b 均为对象!! // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. // 通过构造函数来判断 a 和 b 是否相同 // 但是，如果 a 和 b 的构造函数不同 // 也并不一定 a 和 b 就是 unequal // 比如 a 和 b 在不同的 iframes 中！ // aCtor instanceof aCtor 这步有点不大理解，啥用？ var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; (&#39;constructor&#39; in a &amp;&amp; &#39;constructor&#39; in b)) { return false; } } // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It&#39;s done here since we only need them for objects and arrays comparison. // 第一次调用 eq() 函数，没有传入 aStack 和 bStack 参数 // 之后递归调用都会传入这两个参数 aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) { // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; } // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. // 将嵌套的对象和数组展开 // 如果 a 是数组 // 因为嵌套，所以需要展开深度比较 if (areArrays) { // Compare array lengths to determine if a deep comparison is necessary. // 根据 length 判断是否应该继续递归对比 length = a.length; // 如果 a 和 b length 属性大小不同 // 那么显然 a 和 b 不同 // return false 不用继续比较了 if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) { // 递归 if (!eq(a[length], b[length], aStack, bStack)) return false; } } else { // 如果 a 不是数组 // 进入这个判断分支 // Deep compare objects. // 两个对象的深度比较 var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. // a 和 b 对象的键数量不同 // 那还比较毛？ if (_.keys(b).length !== length) return false; while (length--) { // Deep compare each member // 递归比较 key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; } } // Remove the first object from the stack of traversed objects. // 与 aStack.push(a) 对应 // 此时 aStack 栈顶元素正是 a // 而代码走到此步 // a 和 b isEqual 确认 // 所以 a，b 两个元素可以出栈 aStack.pop(); bStack.pop(); // 深度搜索递归比较完毕 // 放心地 return true return true; }; ​ 1. isNaN ====&gt; _.isNaN(new Number(0)) =&gt; true 2. 实用功能 1. noConflict: 把 “_” 变量的控制权预留给它原有的所有者. 返回一个引用给 Underscore 对象 2. identity: 返回与传入参数相等的值. 相当于数学里的: f(x) = x 3. times: 执行某函数n次 4. escape,unescape:转义HTML字符串，反转到HTML字符串 ```javascript console.log(_.escape(&#39;Curly, Larry &amp; Moe&#39;)); =&gt; Curly, Larry &amp;amp; Moe console.log(_.unescape(&#39;Curly, Larry &amp;amp; Moe&#39;)); =&gt; Curly, Larry &amp; Moe ​ ​ ​ 链式 chain: 返回一个封装的对象。在封装的对象上调用方法会返回封装的对象本身，直到value()方法调用为止。 var stooges = [{name : &#39;curly&#39;, age : 25}, {name : &#39;moe&#39;, age : 21}, {name : &#39;larry&#39;, age : 23}]; var youngest = _.chain(stooges) .sortBy(function(stooge){ return stooge.age; }) .map(function(stooge){ return stooge.name + &#39; is &#39; + stooge.age; }) .first() .value(); console.log(youngest); =&gt; moe is 21 ​ 可能不是很需要underscore 数组Iterate Underscore _.each(array, iteratee) ES5.1 array.forEach(iteratee) Map Underscore _.map(array, iteratee) ES5.1 array.map(iteratee) Use a function to accumulate a single value from an array (left-to-right) Underscore _.reduce(array, iteratee, memo) ES5.1 array.reduce(iteratee, memo) Use a function to accumulate a single value from an array (right-to-left) Underscore _.reduceRight(array, iteratee, memo) ES5.1 array.reduceRight(iteratee, memo) Test whether all elements in an array pass a predicate Underscore _.every(array, predicate) ES5.1 array.every(predicate) Test whether some element in an array passes a predicate Underscore _.some(array, predicate) ES5.1 array.some(predicate) Find a value in an array Underscore _.find(array, predicate) ES2015 array.find(predicate) Get a property from each element in an array Underscore _.pluck(array, propertyName) ES2015 array.map(value =&gt; value[propertyName]) Check if array includes an element Underscore _.includes(array, element) ES2016 array.includes(element) Convert an array-like object to array Underscore _.toArray(arguments) ES2015 [...arguments] Convert an array of keys and values to an object Underscore _.object(array) ES2015 array.reduce((result, [key, val]) =&gt; Object.assign(result, {[key]: val}), {}) Object Rest/Spread (Stage 2) array.reduce((result, [key, val]) =&gt; {...result, [key]: val}, {}) Create a copy of an array with all falsy values removed Underscore _.compact(array) ES5.1 array.filter(Boolean) ES2015 array.filter(x =&gt; !!x) Create a copy of an array with duplicates removed Underscore _.uniq(array) ES2015 [...new Set(array)] Find the index of a value in an array Underscore _.indexOf(array, value) ES5.1 array.indexOf(value) Find the index in an array by predicate Underscore _.findIndex([4, 6, 7, 12], isPrime); ES2015 [4, 6, 7, 12].findIndex(isPrime); Create an array with n numbers, starting from x Underscore _.range(x, x + n) ES2015 Array.from(Array(n), (_, i) =&gt; x + i) ObjectsNames of own enumerable properties as an array Underscore _.keys(object) ES5.1 Object.keys(object) Number of keys in an object Underscore _.size(object) ES5.1 Object.keys(object).length Names of all enumerable properties as an array Underscore _.allKeys(object) ES2015 [...Reflect.enumerate(object)] Values Underscore _.values(object) ES2015 Object.keys(object).map(key =&gt; object[key]) Create a new object with the given prototype and properties Underscore _.create(proto, properties) ES2015 Object.assign(Object.create(proto), properties) Create a new object from merged own properties Underscore _.assign({}, source, { a: false }) ES2015 Object.assign({}, source, { a: false }) Object Rest/Spread (Stage 2) { ...source, a: false } Create a shallow clone of own properties of an object Underscore _.extendOwn({}, object) Object Rest/Spread (Stage 2) { ...object } Check if an object is an array Underscore _.isArray(object) ES5.1 Array.isArray(object) Check if an object is a finite Number Underscore _.isNumber(object) &amp;&amp; _.isFinite(object) ES2015 Number.isFinite(object) FunctionsBind a function to an object Underscore foo(_.bind(function () { this.bar(); }, this)); foo(_.bind(object.fun, object)); ES2015 foo(() =&gt; { this.bar(); }); foo(() =&gt; object.fun()); UtilityIdentity function Underscore _.identity ES2015 value =&gt; value A function that returns a value Underscore _.constant(value) ES2015 () =&gt; value The empty function Underscore _.noop ES2015 () =&gt; {} Get the current time in milliseconds since the epoch Underscore _.now() ES5.1 Date.now() Template Underscore var greeting = _.template(&quot;hello &lt;%= name %&gt;&quot;); greeting({ name: &#39;moe&#39; }); ES2015 const greeting = ({ name }) =&gt; `hello ${name}`; greeting({ name: &#39;moe&#39; });","categories":[],"tags":[{"name":"Learning summary","slug":"Learning-summary","permalink":"http://lo-que.github.io/tags/Learning-summary/"}]},{"title":"get post 的八个方法&&状态码","slug":"get-post-的八个方法-状态码","date":"2017-12-16T12:14:20.000Z","updated":"2018-04-24T10:41:57.000Z","comments":true,"path":"2017/12/16/get-post-的八个方法-状态码/","link":"","permalink":"http://lo-que.github.io/2017/12/16/get-post-的八个方法-状态码/","excerpt":"","text":"get 获取数据post 向指定资源提交数据put 更新 最新信息 头像delete 删除head 同get 不要求全部内容状态码 1xx 请求信息 2xx 表示成功3xx 重定向 4xx客户端错误 5xx服务器端错误200 ok 成功 400 语法错误 401 未经过授权403 拒绝提供服务 没有权限 404 未找到 500 不可预期的一个错误 503 当前不能处理 过段时间才能恢复正常","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"圣杯布局与双飞燕布局","slug":"圣杯布局与双飞燕布局","date":"2017-11-11T12:10:58.000Z","updated":"2018-04-24T10:41:29.000Z","comments":true,"path":"2017/11/11/圣杯布局与双飞燕布局/","link":"","permalink":"http://lo-que.github.io/2017/11/11/圣杯布局与双飞燕布局/","excerpt":"","text":"圣杯布局固比固布局 圣杯布局的出现是来自于a list part上的一篇文章In Search of the Holy Grail。比起双飞翼布局，它的起源不是源于对页面的形象表达。在西方，圣杯是表达“渴求之物”的意思。而双飞翼布局则是源于淘宝的UED，可以说是灵感来自于页面渲染。 通过缩放页面可以发现，随着页面的宽度的变化，这三栏布局是中间盒子优先渲染，两边的盒子框子固定不变，即使页面宽度变小，也不影响我们的浏览。注意：当你缩放页面的时候，宽度不能小于700PX，为了安全起见，最好还是给body加一个最小宽度! &lt;header&gt;&lt;h4&gt;Header内容区&lt;/h4&gt;&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;&lt;h4&gt;中间弹性区&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;h4&gt;左边栏&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;h4&gt;右边栏&lt;/h4&gt;&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;h4&gt;Footer内容区&lt;/h4&gt;&lt;/footer&gt; 此时一定要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染嘛~并且设置其自适应，也就是width:100%。 header { width: 100%; height: 40px; background-color: darkseagreen; } .container { height:200px; overflow:hidden; } .middle { width: 100%; height: 200px; background-color: deeppink; float:left; } .left { width: 200px; height: 200px; background-color: blue; float:left; } .right { width: 200px; height: 200px; background-color: darkorchid; float:left; } footer { width: 100%; height: 30px; background-color: darkslategray; } 此时，三栏并没有在父元素的一行显示，就是因为中间盒子我们给了百分之百的宽度。所有左右两个盒子才会被挤下来。那么如何让它们呈现出一行三列的效果呢？那就要让左边的盒子要到中间盒子的最左边，右边的盒子到中间盒子的最右边。换个想法，如果中间盒子不是100%的宽度，那么按照文档流，左边的盒子一定会在中间盒子的后面显示，接着显示右边的盒子。但是现在中间盒子是满屏了的，所以左右两个盒子被挤到下一行显示。我们要做到的是让左右两个盒子都上去。可以使用CSS的负边距(negative margin)。 让左边的盒子上去 需要设置其左边距为负的中间盒子的宽度，也就是.left {margin-left:-100%;}。这样左盒子才可以往最左边移动。 让右边的盒子上去 需要设置其左边距为负的自己的宽度，也就是.right {margin-left：-200px;}。这样右盒子才可以在一行的最右边显示出自己。 此时，我们初步实现了效果，然而我们的工作才刚刚开始。此时的中间盒子是自适应的宽度，所以中间盒子的内容会被左边的盒子给覆盖掉一部分。 首先:利用父级元素设置左右内边距的值，把父级的三个子盒子往中间挤。.container{padding:0 200px;}这里的200px就是我们想要设置的左右盒子的宽度，此时先预留好。 最后.left{ position: relative; left: -200px;}.right{position: relative;right: -210px; 其实还有另外的解决方案.middle{padding-right:200px;padding-left:200px;box-sizing:border-box;}但是这种方案对以后的发展不利，限制了以后可能的使用场景。 还有.middle {width: calc(100% - 400px);margin: 0 auto;}不过这种写法职能兼容IE9及以上版本，而且性能不是很好。 双飞翼布局圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。 双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4）","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"modules.exports与exports","slug":"modules-exports与exports","date":"2017-10-24T13:15:57.000Z","updated":"2018-04-24T10:42:06.000Z","comments":true,"path":"2017/10/24/modules-exports与exports/","link":"","permalink":"http://lo-que.github.io/2017/10/24/modules-exports与exports/","excerpt":"","text":"1. module.exports 初始值为一个空对象 {} 2. exports 是指向的 module.exports 的引用 3. require() 返回的是 module.exports 而不是 exports","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"data chunk","slug":"data-chunk","date":"2017-10-24T08:57:24.000Z","updated":"2018-04-24T10:41:48.000Z","comments":true,"path":"2017/10/24/data-chunk/","link":"","permalink":"http://lo-que.github.io/2017/10/24/data-chunk/","excerpt":"","text":"首先 组装chunk var data = &quot;&quot; res .on(&#39;data&#39;, function (chunk) { data += chunk }) .on(&quot;end&quot;, function () { //对data转码 }) 但是 当我们调用的时候就会发现 var testIconv = new Iconv(&#39;GBK&#39;, &#39;UTF-8&#39;) testIconv.convert(data).toString() 会抛出EILSEQ异常 仔细查看会发现两个chunk（Buffer对象）的拼接并不正常，相当于进行了buffer.toString() + buffer.toString()。如果buffer不是完整的，则toString出来后的string是存在问题的（比如一个中文字被截断）。这样出来的string就无法被正常转码。 所以应该这样拼接 var chunks = [] var size = 0 res .on(&#39;data&#39;, function (chunk) { chunks.push(chunk) size += chunk.length }) .on(&#39;end&#39;, function () { var data = null switch(chunks.length) { case 0: data = new Buffer(0) break case 1: data = chunks[0] break default: data = new Buffer(size); for (var i = 0, pos = 0, l = chunks.length; i &lt; l; i++) { var chunk = chunks[i] chunk.copy(data, pos) pos += chunk.length } break } }) 对其进行封装重构 var BufferHelper = function () { this.buffers = [] this.size = 0 this._status = &quot;changed&quot; } BufferHelper.prototype.concat = function (buffer) { for (var i = 0, l = arguments.length; i &lt; l; i++) { this._concat(arguments[i]) } return this } BufferHelper.prototype._concat = function (buffer) { this.buffers.push(buffer) this.size = this.size + buffer.length this._status = &quot;changed&quot; return this } BufferHelper.prototype._toBuffer = function () { var data = null var buffers = this.buffers switch(buffers.length) { case 0: data = new Buffer(0) break case 1: data = buffers[0] break default: data = new Buffer(this.size) for (var i = 0, pos = 0, l = buffers.length; i &lt; l; i++) { var buffer = buffers[i] buffer.copy(data, pos) pos += buffer.length } break } // Cache the computed result this._status = &quot;computed&quot; this.buffer = data return data } BufferHelper.prototype.toBuffer = function () { return this._status === &quot;computed&quot; ? this.buffer : this._toBuffer() } BufferHelper.prototype.toString = function () { return Buffer.prototype.toString.apply(this.toBuffer(), arguments) } module.exports = BufferHelper 这里有两个私有方法，_concat和_toBuffer。其目的是保证每个方法的职责单一，还在toBuffer里做了一下状态设置，使得不浪费CPU。接下来的调用就非常简单了。 var http = require(&#39;http&#39;) var BufferHelper = require(&#39;bufferhelper&#39;) http.createServer(function (request, response) { var bufferHelper = new BufferHelper() request.on(&quot;data&quot;, function (chunk) { bufferHelper.concat(chunk) }) request.on(&#39;end&#39;, function () { var html = bufferHelper.toBuffer().toString() response.writeHead(200) response.end(html) }) }).listen(8001) 最后，node-iconv的作者提供了一个工具集node-iconv 以上是朴灵大大很久前发表在cnodejs.org上的文章, 现在可以把chunk push进临时数组, 之后concat拼接下, 代码如下 dataArray.push(chunk) Buffer.concat(dataArray).toString(‘base64’)","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"html语义化","slug":"html语义化","date":"2017-08-19T13:20:41.000Z","updated":"2018-04-24T10:42:00.000Z","comments":true,"path":"2017/08/19/html语义化/","link":"","permalink":"http://lo-que.github.io/2017/08/19/html语义化/","excerpt":"","text":"Learnning Notehtml语义化 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置; 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来;","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"extends","slug":"extends","date":"2017-08-16T13:12:35.000Z","updated":"2018-04-24T10:41:52.000Z","comments":true,"path":"2017/08/16/extends/","link":"","permalink":"http://lo-que.github.io/2017/08/16/extends/","excerpt":"","text":"Learnning Noteextends理解extends block 拓展调用 在本文件中（使用extengds的文件中）调用 block content 将之后的代码整合为块 实际上在 被extends的文件中 使用 佐证 在被extengds的文件中 更换 block content与block desc的顺序 可证 doctype html &lt;!--[if IE 8]&gt;&lt;html class=&#39;ie8&#39;&gt;&lt;![endif]--&gt; &lt;!--[if IE 9]&gt;&lt;html class=&#39;ie9&#39;&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;html&gt;&lt;!--&lt;![endif]--&gt; head meta(charset=&#39;utf8&#39;) - var course = &#39;jade&#39; title #{course.toUpperCase()} body block content block desc p 测试 &lt;/html&gt; index.jade 实际上在指向layout.jade var index = layout include才是引用 在本文件中使用被include的文件中的代码","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"async && defer","slug":"async-defer","date":"2017-06-18T13:05:37.000Z","updated":"2018-04-24T10:42:15.000Z","comments":true,"path":"2017/06/18/async-defer/","link":"","permalink":"http://lo-que.github.io/2017/06/18/async-defer/","excerpt":"","text":"Learnning Noteasync defer查阅资料 &lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics 自己理解 默认引用 script:&lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。 async模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。 defer模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"XMLHttpRequest","slug":"XMLHttpRequest","date":"2017-06-10T03:01:34.000Z","updated":"2018-04-24T10:42:11.000Z","comments":true,"path":"2017/06/10/XMLHttpRequest/","link":"","permalink":"http://lo-que.github.io/2017/06/10/XMLHttpRequest/","excerpt":"","text":"0 (未初始化)： (XMLHttpRequest)对象已经创建，但还没有调用open()方法。1 (载入)：已经调用open() 方法，但尚未发送请求。2 (载入完成)： 请求已经发送完成。3 (交互)：可以接收到部分响应数据。4 (完成)：已经接收到了全部数据，并且连接已经关闭。","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"从输入Url到页面加载完成之间都发生了什么事","slug":"从输入Url到页面加载完成之间都发生了什么事","date":"2017-04-19T11:20:27.000Z","updated":"2018-04-24T10:40:55.000Z","comments":true,"path":"2017/04/19/从输入Url到页面加载完成之间都发生了什么事/","link":"","permalink":"http://lo-que.github.io/2017/04/19/从输入Url到页面加载完成之间都发生了什么事/","excerpt":"","text":"Learnning Note从输入Url到页面加载完成之间都发生了什么事 chrome搜索自身的dns缓存 搜索操作系统自身的dns缓存（浏览器没有找抖缓存或缓存已经失效） 读取本地的HOST文件 浏览器发起一个dns的系统调用 宽带运营商服务器查看本身缓存 运营商服务器发起一个迭代dns解析的请求 运营商-根域-com域的顶级域-com域（域名的注册商提供） 运营商服务器吧结果返回操作系统内核同时缓存起来 操作系统内核把结果返回浏览器 最终由浏览器拿到 浏览器获得域名对应的ip地址后，发起HTTP三次握手 tcp／ip连接建立起来后，浏览器就可以向服务器发送HTTP请求了 服务器端接受到了这个请求，根据路径参数，经过后段的一些处理之后，把处理后的一个结果的数据返回给浏览器html 浏览器拿到html 剩下的css js 图片之类的资源都要经过以上7步 浏览器根据拿到的资源对画面进行渲染 请求和响应 都会发送http头和正文信息 google一下发现大神文章从输入url到页面加载完成之间都发生了什么 更简洁的理解 浏览器检查缓存，如果请求的对象缓存是新的，跳到# 9 浏览器询问操作系统服务器的IP地址 操作系统进行DNS查找并将IP地址回复到浏览器 浏览器打开一个TCP连接到服务器（这一步要复杂得多） 浏览器通过TCP连接发送HTTP请求 浏览器接收HTTP响应，并可能关闭TCP连接，或为另一个请求重用它。 浏览器检查响应是否是一个重定向或条件反应（3xx结果状态码），授权请求（401），错误（4xx和5XX），等等；这些不同于正常的反应处理（2xx） 如果缓存，响应存储在高速缓存 浏览器解码响应（不考虑gzip压缩） 浏览器决定如何处理响应（例如它是一个HTML页面，它是一个图像，它是一个声音剪辑吗？） 浏览器呈现响应，或提供未识别类型的下载对话框。 此外，还有很多其他的事情发生在平行于这个（地址，输入处理投机性预取，增加网页浏览历史，用户，显示进度通知插件和扩展，渲染页面的同时它的下载，流水线，为保持活着，检查恶意内容等跟踪连接）和整个操作得到的幅度更复杂的命令（HTTPS证书和密码以及ssl pining)","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"浏览器不兼容h5","slug":"浏览器不兼容h5","date":"2017-04-16T11:23:38.000Z","updated":"2018-04-24T10:41:03.000Z","comments":true,"path":"2017/04/16/浏览器不兼容h5/","link":"","permalink":"http://lo-que.github.io/2017/04/16/浏览器不兼容h5/","excerpt":"","text":"在进行毕业设计的过程中 遇见了浏览器不兼容h5的问题第一种方法：IE9以下版本的IE将创建HTML5标签， 非IE浏览器会忽略这段代码，因此不会发生http请求，也就不影响网页执行效率 &lt;!--[if lt IE9]&gt; &lt;script&gt; (function() { if (! /*@cc_on!@*/ 0) return; var e = &quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;.split(&#39;, &#39;); var i= e.length; while (i--){ document.createElement(e[i]) } })() &lt;/script&gt; &lt;![endif]--&gt; 第二种方法：在你的网页中引入Google的html5shiv包（推荐） &lt;!--[if lt IE9]&gt; &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局 /html5/article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}但是如果ie6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢? 我们可以参照facebook的做法，即引导用户进入带有noscript标识的 “/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。 &lt;!--[if lte IE 8]&gt; &lt;noscript&gt; &lt;style&gt;.html5-wrappers{display:none!important;}&lt;/style&gt; &lt;div class=&quot;ie-noscript-warning&quot;&gt;您的浏览器禁用了脚本，请&lt;a href=&quot;&quot;&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href=&quot;/?noscript=1&quot;&gt;继续访问&lt;/a&gt;. &lt;/div&gt; &lt;/noscript&gt; &lt;![endif]--&gt; 引导用户开启脚本,或者直接跳转到HTML4标签设计的界面。 其他： Dean Edwards的IE7.js (以及 IE8.js, IE9.js) 这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。 Aaron Gustafson的 eCSStender 此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。 Drew Diller的 DD_roundies 这是一个基于IE VML实现一些CSS3效果的。 Remiz Rahnas的border-radius.htc 此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。 Nick Fetchak的 ie-css3.htc 关于此方法，我在前面的”让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。 Keith Clark的ie-css3.js 这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。 zoltandulac的cssSandpaper 这是一个使用IE滤镜实现一些CSS3属性的方法。 css3pie的css3 PIE.htc 支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。 下面对第8第方法的做一下简单介绍： 官方网站：http://css3pie.com/ 使用方法： 第一步：下载css3 PIE.htc 文件 第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。 第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段： #id { border: 1px solid #999; -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px; behavior: url(path/to/PIE.htc); } 注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。 已知的一些问题： 此方法并不是万能的，也有一些局限性和需要注意的地方。 z-index相关问题 IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素 position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。 所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器 下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并 赋予一个z-index值（不可为-1）。 相当路径的问题 IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目 录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border- image后面的URL属性路径也不好处理。 缩写的问题 使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。 提供正确的Content-Type 要想让IE浏览器支持htc文件，需要一个有着”text/x-component” 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。 如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理： AddType text/x-component .htc 但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下： &lt;?php header( &#39;Content-type: text/x-component&#39; ); include( &#39;pie.htc&#39; ); ?&gt; 通过PHP文件来增加一个含有”text/x-component”字样的Content-type头，同时调用pie.htc文件。 关于上面所示的php文件，您可以狠狠地点击这里：pie.php(右键 – [目标|链接另存为])，或者您可以直接新建一个php文件，把上面的两行代码复制进去。或者在本文提供的原始打包资源的wrappers文件夹里面也有此php文件，不过名称是大写的。 如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是： behavior: url(pie.php);","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"什么是SSL Pining","slug":"什么是SSL-Pining","date":"2017-04-04T14:53:54.000Z","updated":"2018-04-24T10:50:07.000Z","comments":true,"path":"2017/04/04/什么是SSL-Pining/","link":"","permalink":"http://lo-que.github.io/2017/04/04/什么是SSL-Pining/","excerpt":"","text":"SSL(Secure Socket Layer 安全套接字层)确保客户端-服务器在HTTP请求的方式上将通讯内容加密—-被指定为HTTPS(SSL上的HTTP)。这种加密体系是基于PKI(Pbulic Key Infrastructure,公钥体系)和(Session key,会话key)。其中Session key 被引进的原因是对于公钥/私钥的加密和解密会消耗处理能力，会是整个交流进程速度变慢。 SSL 安全—鉴定 SSL安全是基于证书的信任链。当一个通信开始的时候，客户端检查服务器的SSL证书，检查这个证书是否被信用根CA机构或者其他用户信任结构所信任。 尽管SSL通信被认为是一个非常安全的和坚不可摧的，但是中间人攻击依然还是真实存在的威胁，它可以用好几种方法去实现，例如ARP 缓存中毒、DNS 欺骗等。 对于ARP缓存中毒，可以简单理解为中间人通过地址解析协议的IP映射到设备的Mac地址这一特性进行攻击。例如，我们用一下三个角色来描述一个简单的网络： 一个普通的用户设备U 攻击者的设备A 路由器R 攻击者的设备A可以发送一个ARP依赖包给用户设备U，把他自己伪装成路由器R。为了完成中间人攻击，A发送另一个ARP依赖给R，告诉路由器它就是U。这样的话，A就成了U和R沟通的中间者，A就可以窃听和拦截信息。IP转发经常被用于攻击者在用户设备和路由器的无缝交流。也就是说通过IP转发，攻击者可以窃取和监听，但是用户和路由器是无感知的。 DNS欺骗主要在于攻击者破话服务器的域名映射。攻击者尝试强迫DNS去返回一个不正确的地址，而这个地址就是攻击者的计算机地址。 SSL pinning https协议验证服务器身份的方式通常有三种，一是根据浏览器或者说操作系统自带的证书链；二是使用自签名证书；三是自签名证书加上SSL Pinning特性。第一种需要到知名证书机构购买证书，需要一定预算。第二种多见于内网使用。第三种在是安全性最高的，但是需要浏览器插件或客户端使用了SSL Pinning特性。 所以SSL Pinning，即SSL证书绑定，是验证服务器身份的一种方式，是在https协议建立通信时增加的代码逻辑，它通过自己的方式验证服务器身份，然后决定通信是否继续下去。它唯一指定了服务器的身份，所以安全性较高。 我们使用SSL pinning来确保app通信仅仅发生在指定的服务器上。其中的先决条件就是价格目标服务器的SSL证书放到app里面。这个证书被用于会话配置。","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]},{"title":"call && apply","slug":"call-apply","date":"2017-01-13T12:11:26.000Z","updated":"2018-04-24T10:41:34.000Z","comments":true,"path":"2017/01/13/call-apply/","link":"","permalink":"http://lo-que.github.io/2017/01/13/call-apply/","excerpt":"","text":"call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 function add(a,b) { this(a,b) alert(a+b) } function sub(a,b) { alert(a-b) } add.call(sub,3,1)//2,4 add.call(sub,3,1)将add执行的上下文由window切换为sub，即this指向是从window变为sub。 首先 add.call(sub,3,1)执行的是 add方法， 然后，add执行的时候，this已经变成了 sub这个方法本身，所以this(a,b)这一句弹出了2。 function Animal(name){ this.name = name this.showName = function(){ alert(this.name) } } function Cat(name){ Animal.call(this, name) } var cat = new Cat(&quot;Black Cat&quot;) cat.showName() 首先执行var cat = new Cat(“Black Cat”)进入function Cat(name){ function Cat(name){ Animal.call(this, name) } 这时候的this为Cat{}对象，并非Animal，再接执行 function Animal(name){ this.name = name this.showName = function(){ alert(this.name) } } 此时的this对象绑定为Cat{},因此是Cat对象获得了两个属性为： Cat{name: &quot;Black Cat&quot;,showName:function() { alert(this.name) }}， 回到 var cat = Cat{ name:&quot;Black Cat&quot;, showName:function() { alert(this.name) }} 最后才是cat.showName()","categories":[],"tags":[{"name":"Learning Note","slug":"Learning-Note","permalink":"http://lo-que.github.io/tags/Learning-Note/"}]}]}