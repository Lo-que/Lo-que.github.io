                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          [{"title":"css 命名规范","url":"/2018/01/24/css-命名规范/","content":"Learnning Notecss命名规范base头：header内容：content/container尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center登录条：loginbar标志：logo广告：banner页面主体：main热点：hot新闻：news下载：download子导航：subnav菜单：menu子菜单：submenu搜索：search友情链接：friendlink页脚：footer版权：copyright滚动：scroll内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guide服务：service注册：register状态：status投票：vote合作伙伴：partner注释/ Header /内容区/ End Header /id的命名:(1)页面结构容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中：left right center(2)导航导航：nav主导航：mainbav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary(3)功能标志：logo广告：banner登陆：login登录条：loginbar注册：register搜索：search功能区：shop（如购物车）标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guide服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyrightclass命名(1)颜色:使用颜色的名称或者16进制代码,如.red { color: red; }.f60 { color: #f60; }.ff8600 { color: #ff8600; }    (2)字体大小,直接使用”font+字体大小”作为名称,如.font10px { font-size: 10px; }.font6pt {font-size: 6pt; }    (3)对齐样式,使用对齐目标的英文名称,如.left { float:left; }.bottom { float:bottom; }    (4)标题栏样式,使用”类别+功能”的方式命名,如.barnews { }.barproduct { } 注意事项: class 名称中只能出现小写字符和连字符（不是下划线，也不是驼峰命名法）。连字符应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。class 名称应当尽可能短，并且意义明确。使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。基于最近的父 class 或基本（base） class 作为新 class 的前缀。使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。样式命名1）　主要的 master.css布局，版面 layout.css专栏 columns.css文字 font.css打印样式 print.css主题 themes.css    2）reset.css // 对浏览器的默认样式进行重设layout.css // 管理页面的布局typeset.css // 图文的编排color.css // 统一管理颜色的搭配print.css // 打印效果样式ie.css // 把对ie的hack单独分开     3）reset.cssheader.css // 头部的所有样式container.css // 除头部/底部外的中间区域样式footer.css // 底部样式print.cssie.css     4）reset.css / 页面样式重置 /header.css / 全站头部样式 /footer.css / 全站尾部样式 /public.css / 全站公共模块样式 /index.css / 首页特有样式 /container.css / 二级及以下主体样式 /print.css / 打印样式 /ie.css / IE hack /    ","tags":["Learning Note"]},{"title":"underscore学习小结","url":"/2018/01/22/underscore学习小结/","content":"underscore.jsUnderscore.js 是一个由Jeremy Ashkenas开发的JavaScript库，提供了许多作为开发者在开发Web项目时所需要的实用功能。代码变得更加易读： _.isEmpty({})  //true代码更容易编写：_.flatten([[0, 1], [2, 3], [4, 5]]) // [0, 1, 2, 3, 4, 5] 提供了原生没有的方法：_.range(5)  //[0, 1, 2, 3, 4]甚至可以作为模版引擎：_.template(&#39;&lt;p&gt;&lt;%= text %&gt;&lt;/p&gt;&#39;, {text: &#39;SitePoint Rocks!&#39;}) //   &lt;p&gt;SitePoint Rocks!&lt;/p&gt;USA Today   今日美国LinkedIn  领英Khan Academy  可汗学院集合：数组或对象each 对集合循环操作，只针对functionmap 对集合以map方式进行遍历，返回一个新数组  iteratee 可以是对象或字符串reduce: 按callback缩减集合filter: 过滤器  _.find =  _.detect 返回第一个reject: 过滤不符合要求的where: 根据指定键值对 遍历list，返回新的数组。（类似于sql语句中的where）&amp;： find 返回第一个_.contains = _.includes = _.include: 判断数组或者对象中（value 值）是否有指定元素every = all  所有满足 返回truesome = any  只有有一个满足 返回trueinvoke:  数组或者对象中的每个元素都调用 method 方法，返回调用后的结果（数组或者关联数组）pluck: 提取一个集合里指定的属性值max,min,sortBy: 取list中的最大，最小元素，自定义比较器​shuffle 随机打乱 洗牌算法partition 将数组或者对象中符合条件的元素和不符合条件的元素分别放入两个数组数组_.first = _.head = _.take 返回前n个元素 n默认为1initial 返回出去后n个元素的数组last 返回后n个元素rest = tail 返回出去前n个元素compact  去除数组中所有的假值 false null undefined ‘’ NaN 0√ flatten 将数组展开  without 从数组中移除指定的元素，返回移除后的数组副本union,intersection,difference,uniq: 并集，交集，差集，取唯一(去重)zip unzip 合并数组中的元素 是group的反向操作indexOf,lastIndexOf, 取索引位置 sortedIndex 二分查找​函数bind: this指向不变  bindAll 绑定方法名到对象上, 当这些方法被执行时将在对象的上下文执行. 绑定函数用作事件处理时非常方便, 否则函数调用时 this 关键字根本没什么用​partial:在不改变this的情况下，通过参数填充数据  可以使方法设定默认值 柯里化(Currying)​memoize 记忆化，存储中间运算结果，提高效率​delay: 延迟触发 setTimeout   _.defer = _.partial ( _.delay, _, 1);throttle: 函数节流（如果有连续事件响应，则每间隔一定时间段触发）debounce: 函数去抖（连续事件触发结束后只触发一次）wrap 以函数作为函数传递，可以增加函数前后的控制​compose: 组合函数调用关系，把单独的f(),g(),h()组合成f(g(h()))对象​keys,values,paris,invert: 取属性名，取属性值，把对象转换成[key,value]数组，对调键值​extend: 复制对象的所有属性到目标对象上，覆盖已有属性defaults: 复制对象的所有属性到目标对象上，跳过已有属性  ​​​链式chain: 返回一个封装的对象。在封装的对象上调用方法会返回封装的对象本身，直到value()方法调用为止。​可能不是很需要underscore数组IterateUnderscoreES5.1MapUnderscoreES5.1Use a function to accumulate a single value from an array (left-to-right)UnderscoreES5.1Use a function to accumulate a single value from an array (right-to-left)UnderscoreES5.1Test whether all elements in an array pass a predicateUnderscoreES5.1Test whether some element in an array passes a predicateUnderscoreES5.1Find a value in an arrayUnderscoreES2015Get a property from each element in an arrayUnderscoreES2015Check if array includes an elementUnderscoreES2016Convert an array-like object to arrayUnderscoreES2015Convert an array of keys and values to an objectUnderscoreES2015Object Rest/Spread (Stage 2)Create a copy of an array with all falsy values removedUnderscoreES5.1ES2015Create a copy of an array with duplicates removedUnderscoreES2015Find the index of a value in an arrayUnderscoreES5.1Find the index in an array by predicateUnderscoreES2015Create an array with n numbers, starting from xUnderscoreES2015ObjectsNames of own enumerable properties as an arrayUnderscoreES5.1Number of keys in an objectUnderscoreES5.1Names of all enumerable properties as an arrayUnderscoreES2015ValuesUnderscoreES2015Create a new object with the given prototype and propertiesUnderscoreES2015Create a new object from merged own propertiesUnderscoreES2015Object Rest/Spread (Stage 2)Create a shallow clone of own properties of an objectUnderscoreObject Rest/Spread (Stage 2)Check if an object is an arrayUnderscoreES5.1Check if an object is a finite NumberUnderscoreES2015FunctionsBind a function to an objectUnderscoreES2015UtilityIdentity functionUnderscoreES2015A function that returns a valueUnderscoreES2015The empty functionUnderscoreES2015Get the current time in milliseconds since the epochUnderscoreES5.1TemplateUnderscoreES2015","tags":["Learning summary"]},{"title":"get post 的八个方法&&状态码","url":"/2017/12/16/get-post-的八个方法-状态码/","content":"get  获取数据post 向指定资源提交数据put 更新    最新信息   头像delete 删除head  同get  不要求全部内容状态码  1xx 请求信息  2xx 表示成功3xx 重定向 4xx客户端错误 5xx服务器端错误200  ok 成功  400  语法错误  401 未经过授权403 拒绝提供服务  没有权限  404 未找到 500 不可预期的一个错误 503  当前不能处理  过段时间才能恢复正常  ","tags":["Learning Note"]},{"title":"圣杯布局与双飞燕布局","url":"/2017/11/11/圣杯布局与双飞燕布局/","content":"圣杯布局固比固布局圣杯布局的出现是来自于a list part上的一篇文章In Search of the Holy Grail。比起双飞翼布局，它的起源不是源于对页面的形象表达。在西方，圣杯是表达“渴求之物”的意思。而双飞翼布局则是源于淘宝的UED，可以说是灵感来自于页面渲染。通过缩放页面可以发现，随着页面的宽度的变化，这三栏布局是中间盒子优先渲染，两边的盒子框子固定不变，即使页面宽度变小，也不影响我们的浏览。注意：当你缩放页面的时候，宽度不能小于700PX，为了安全起见，最好还是给body加一个最小宽度!此时一定要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染嘛~并且设置其自适应，也就是width:100%。此时，三栏并没有在父元素的一行显示，就是因为中间盒子我们给了百分之百的宽度。所有左右两个盒子才会被挤下来。那么如何让它们呈现出一行三列的效果呢？那就要让左边的盒子要到中间盒子的最左边，右边的盒子到中间盒子的最右边。换个想法，如果中间盒子不是100%的宽度，那么按照文档流，左边的盒子一定会在中间盒子的后面显示，接着显示右边的盒子。但是现在中间盒子是满屏了的，所以左右两个盒子被挤到下一行显示。我们要做到的是让左右两个盒子都上去。可以使用CSS的负边距(negative margin)。让左边的盒子上去需要设置其左边距为负的中间盒子的宽度，也就是.left {margin-left:-100%;}。这样左盒子才可以往最左边移动。让右边的盒子上去需要设置其左边距为负的自己的宽度，也就是.right {margin-left：-200px;}。这样右盒子才可以在一行的最右边显示出自己。此时，我们初步实现了效果，然而我们的工作才刚刚开始。此时的中间盒子是自适应的宽度，所以中间盒子的内容会被左边的盒子给覆盖掉一部分。首先:利用父级元素设置左右内边距的值，把父级的三个子盒子往中间挤。.container{padding:0 200px;}这里的200px就是我们想要设置的左右盒子的宽度，此时先预留好。最后.left{ position: relative; left: -200px;}.right{position: relative;right: -210px;其实还有另外的解决方案.middle{padding-right:200px;padding-left:200px;box-sizing:border-box;}但是这种方案对以后的发展不利，限制了以后可能的使用场景。还有.middle {width: calc(100% - 400px);margin: 0 auto;}不过这种写法职能兼容IE9及以上版本，而且性能不是很好。双飞翼布局圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性（圣杯布局中间divpadding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4）","tags":["Learning Note"]},{"title":"modules.exports与exports","url":"/2017/10/24/modules-exports与exports/","content":"","tags":["Learning Note"]},{"title":"data chunk","url":"/2017/10/24/data-chunk/","content":"首先 组装chunk但是 当我们调用的时候就会发现会抛出EILSEQ异常仔细查看会发现两个chunk（Buffer对象）的拼接并不正常，相当于进行了buffer.toString() + buffer.toString()。如果buffer不是完整的，则toString出来后的string是存在问题的（比如一个中文字被截断）。这样出来的string就无法被正常转码。所以应该这样拼接对其进行封装重构这里有两个私有方法，_concat和_toBuffer。其目的是保证每个方法的职责单一，还在toBuffer里做了一下状态设置，使得不浪费CPU。接下来的调用就非常简单了。最后，node-iconv的作者提供了一个工具集node-iconv以上是朴灵大大很久前发表在cnodejs.org上的文章, 现在可以把chunk push进临时数组, 之后concat拼接下, 代码如下","tags":["Learning Note"]},{"title":"html语义化","url":"/2017/08/19/html语义化/","content":"Learnning Notehtml语义化尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；不要使用纯样式标签，如：b、font、u等，改用css设置;需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来;","tags":["Learning Note"]},{"title":"extends","url":"/2017/08/16/extends/","content":"Learnning Noteextends理解extends   block   拓展调用    在本文件中（使用extengds的文件中）调用 block content  将之后的代码整合为块 实际上在 被extends的文件中  使用 佐证  在被extengds的文件中  更换 block content与block desc的顺序 可证 index.jade  实际上在指向layout.jadeinclude才是引用  在本文件中使用被include的文件中的代码","tags":["Learning Note"]},{"title":"async && defer","url":"/2017/06/18/async-defer/","content":"Learnning Noteasync defer查阅资料&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;script async src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics自己理解默认引用 script:&lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。async模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。defer模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。","tags":["Learning Note"]},{"title":"XMLHttpRequest","url":"/2017/06/10/XMLHttpRequest/","content":"0 (未初始化)： (XMLHttpRequest)对象已经创建，但还没有调用open()方法。1 (载入)：已经调用open() 方法，但尚未发送请求。2 (载入完成)： 请求已经发送完成。3 (交互)：可以接收到部分响应数据。4 (完成)：已经接收到了全部数据，并且连接已经关闭。  ","tags":["Learning Note"]},{"title":"从输入Url到页面加载完成之间都发生了什么事","url":"/2017/04/19/从输入Url到页面加载完成之间都发生了什么事/","content":"Learnning Note从输入Url到页面加载完成之间都发生了什么事chrome搜索自身的dns缓存搜索操作系统自身的dns缓存（浏览器没有找抖缓存或缓存已经失效）读取本地的HOST文件浏览器发起一个dns的系统调用宽带运营商服务器查看本身缓存运营商服务器发起一个迭代dns解析的请求运营商-根域-com域的顶级域-com域（域名的注册商提供）运营商服务器吧结果返回操作系统内核同时缓存起来操作系统内核把结果返回浏览器最终由浏览器拿到浏览器获得域名对应的ip地址后，发起HTTP三次握手tcp／ip连接建立起来后，浏览器就可以向服务器发送HTTP请求了服务器端接受到了这个请求，根据路径参数，经过后段的一些处理之后，把处理后的一个结果的数据返回给浏览器html浏览器拿到html  剩下的css js 图片之类的资源都要经过以上7步浏览器根据拿到的资源对画面进行渲染请求和响应 都会发送http头和正文信息google一下发现大神文章从输入url到页面加载完成之间都发生了什么更简洁的理解浏览器检查缓存，如果请求的对象缓存是新的，跳到# 9浏览器询问操作系统服务器的IP地址操作系统进行DNS查找并将IP地址回复到浏览器浏览器打开一个TCP连接到服务器（这一步要复杂得多）浏览器通过TCP连接发送HTTP请求浏览器接收HTTP响应，并可能关闭TCP连接，或为另一个请求重用它。浏览器检查响应是否是一个重定向或条件反应（3xx结果状态码），授权请求（401），错误（4xx和5XX），等等；这些不同于正常的反应处理（2xx）如果缓存，响应存储在高速缓存浏览器解码响应（不考虑gzip压缩）浏览器决定如何处理响应（例如它是一个HTML页面，它是一个图像，它是一个声音剪辑吗？）浏览器呈现响应，或提供未识别类型的下载对话框。此外，还有很多其他的事情发生在平行于这个（地址，输入处理投机性预取，增加网页浏览历史，用户，显示进度通知插件和扩展，渲染页面的同时它的下载，流水线，为保持活着，检查恶意内容等跟踪连接）和整个操作得到的幅度更复杂的命令（HTTPS证书和密码以及ssl pining)","tags":["Learning Note"]},{"title":"浏览器不兼容h5","url":"/2017/04/16/浏览器不兼容h5/","content":"在进行毕业设计的过程中 遇见了浏览器不兼容h5的问题第一种方法：IE9以下版本的IE将创建HTML5标签， 非IE浏览器会忽略这段代码，因此不会发生http请求，也就不影响网页执行效率第二种方法：在你的网页中引入Google的html5shiv包（推荐）但是不管使用以上哪种方法,都要初始化新标签的CSS.因为HTML5在默认情况下表现为内联元素，对这些元素进行布局我们需要利用CSS手工把它们转为块状元素方便布局/html5/article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}但是如果ie6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢?我们可以参照facebook的做法，即引导用户进入带有noscript标识的 “/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。引导用户开启脚本,或者直接跳转到HTML4标签设计的界面。其他：Dean Edwards的IE7.js (以及 IE8.js, IE9.js)这个玩意估计是试图让IE支持CSS3属性的鼻祖，还算蛮强大，就是性能开销较大，要解析很多文件脚本，给DOM添加大量的元素以及ClassName。Aaron Gustafson的 eCSStender此方法支持@font-face, CSS3 选择器, 以及 CSS3 Backgrounds 和 Borders。Drew Diller的 DD_roundies这是一个基于IE VML实现一些CSS3效果的。Remiz Rahnas的border-radius.htc此方法使用htc文件，配合VML实现，缺点在于不能自动适应目标元素的位置和大小，所以不能适用于动态脚本环境。Nick Fetchak的 ie-css3.htc关于此方法，我在前面的”让IE6/IE7/IE8浏览器支持CSS3属性”这篇文章中已经做过介绍。我是建议您看看这篇文章，倒不是ie-css3.htc这个玩意多么好，而是文中对htc文件以及VML预言做了些介绍，对于您了解IE下实现类似CSS3效果原理有所了解。Keith Clark的ie-css3.js这是个与IE7.js类似的项目，其选择器可借助其他JavaScript库，所以其本身较小。zoltandulac的cssSandpaper这是一个使用IE滤镜实现一些CSS3属性的方法。css3pie的css3 PIE.htc支持：border-radius圆角 、 box-shadow 盒阴影 、 gradient渐变 、 multiple background images多背景 。下面对第8第方法的做一下简单介绍：官方网站：http://css3pie.com/使用方法：第一步：下载css3 PIE.htc 文件第二步：将PIE.htc文件上传到你的网站目录中，上传到目录哪里都可以，只要你记住这个目录。第三步：创建html文件，写一段css3代码，并引入PIE.htc，如下面这段：注意：.htc 文件路径是相对于html文件的路径，而不是相对于css文件。已知的一些问题：此方法并不是万能的，也有一些局限性和需要注意的地方。z-index相关问题IE下这些CSS3效果实现是借助于VML，由VML绘制圆角或是投影效果的容器元素，然后这个容器元素作为目标元素的后兄弟节点插入，如果目标元素 position:absolute 或是 position:relative，则这个css3-container元素将会设置与之一样的z-index值，在DOM tree中，同级的元素总是后面的覆盖前面的，所以这样就实现了覆盖，又避免了可能有其他元素正好插入其中。所以，问题来了，如果目前元素的position属性为static，也就是默认属性，则z-index属性是没有用的，无覆盖可言，所以此时IE浏览器 下CSS3的渲染是不会成功的。要解决也很简单，设置目标元素position:relative或是设置祖先元素position:relative并 赋予一个z-index值（不可为-1）。相当路径的问题IE浏览器的behavior 属性是相对于HTML文档而言的，与CSS其他的属性不一样，不是相对于CSS文档而言的。这使得使用pie.htc文件不怎么方便。如果绝对路径于根目 录，则CSS文件不方便移动；如果相对路径与HTML文档，则pie.htc文件在不同HTML页面见的重用性大大降低。同时，诸如border- image后面的URL属性路径也不好处理。缩写的问题使用PIE实现IE下的CSS3渲染（其他方法也是一样），只能使用缩写的形式，例如圆角效果，我们可以设置border-top-left-radius表示左上圆角，但是PIE确实不支持这种写法的，只能是老老实实的缩写。提供正确的Content-Type要想让IE浏览器支持htc文件，需要一个有着”text/x-component” 字样的content-type 头部，否则，会忽视behavior。绝大数web服务器提供了正确的content-type，但是还有一部分则有问题。如果您发现在您的机子上PIE方法无效，也就是htc文件这里指pie.htc文件无效，检查您的服务器配置，可能其需要更新到最新的content-type。例如对于Apache，您可以在.htaccess文件中做如下处理：AddType text/x-component .htc  但是，由于某种原因，您无法修改服务器配置（例如公用主机，或是空间服务商提供的服务器），您可以用一个PHP文件来间接调用htc文件。我只要给你看下这个PHP文件的代码您就知道什么意思了，如下：通过PHP文件来增加一个含有”text/x-component”字样的Content-type头，同时调用pie.htc文件。关于上面所示的php文件，您可以狠狠地点击这里：pie.php(右键 – [目标|链接另存为])，或者您可以直接新建一个php文件，把上面的两行代码复制进去。或者在本文提供的原始打包资源的wrappers文件夹里面也有此php文件，不过名称是大写的。如果您使用上述php文件，您需要将pie.php和pie.htc放在同一个文件夹目录下，同时CSS中的behavior写法应该是：","tags":["Learning Note"]},{"title":"什么是SSL Pining","url":"/2017/04/04/什么是SSL-Pining/","content":"SSL(Secure Socket Layer 安全套接字层)确保客户端-服务器在HTTP请求的方式上将通讯内容加密—-被指定为HTTPS(SSL上的HTTP)。这种加密体系是基于PKI(Pbulic Key Infrastructure,公钥体系)和(Session key,会话key)。其中Session key 被引进的原因是对于公钥/私钥的加密和解密会消耗处理能力，会是整个交流进程速度变慢。　　SSL 安全—鉴定　　SSL安全是基于证书的信任链。当一个通信开始的时候，客户端检查服务器的SSL证书，检查这个证书是否被信用根CA机构或者其他用户信任结构所信任。　　尽管SSL通信被认为是一个非常安全的和坚不可摧的，但是中间人攻击依然还是真实存在的威胁，它可以用好几种方法去实现，例如ARP 缓存中毒、DNS 欺骗等。　　对于ARP缓存中毒，可以简单理解为中间人通过地址解析协议的IP映射到设备的Mac地址这一特性进行攻击。例如，我们用一下三个角色来描述一个简单的网络：　　一个普通的用户设备U　　攻击者的设备A　　路由器R　　攻击者的设备A可以发送一个ARP依赖包给用户设备U，把他自己伪装成路由器R。为了完成中间人攻击，A发送另一个ARP依赖给R，告诉路由器它就是U。这样的话，A就成了U和R沟通的中间者，A就可以窃听和拦截信息。IP转发经常被用于攻击者在用户设备和路由器的无缝交流。也就是说通过IP转发，攻击者可以窃取和监听，但是用户和路由器是无感知的。　　DNS欺骗主要在于攻击者破话服务器的域名映射。攻击者尝试强迫DNS去返回一个不正确的地址，而这个地址就是攻击者的计算机地址。　　SSL pinninghttps协议验证服务器身份的方式通常有三种，一是根据浏览器或者说操作系统自带的证书链；二是使用自签名证书；三是自签名证书加上SSL Pinning特性。第一种需要到知名证书机构购买证书，需要一定预算。第二种多见于内网使用。第三种在是安全性最高的，但是需要浏览器插件或客户端使用了SSL Pinning特性。所以SSL Pinning，即SSL证书绑定，是验证服务器身份的一种方式，是在https协议建立通信时增加的代码逻辑，它通过自己的方式验证服务器身份，然后决定通信是否继续下去。它唯一指定了服务器的身份，所以安全性较高。　　我们使用SSL pinning来确保app通信仅仅发生在指定的服务器上。其中的先决条件就是价格目标服务器的SSL证书放到app里面。这个证书被用于会话配置。","tags":["Learning Note"]},{"title":"call && apply","url":"/2017/01/13/call-apply/","content":"call方法:语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。add.call(sub,3,1)将add执行的上下文由window切换为sub，即this指向是从window变为sub。首先 add.call(sub,3,1)执行的是 add方法， 然后，add执行的时候，this已经变成了 sub这个方法本身，所以this(a,b)这一句弹出了2。首先执行var cat = new Cat(“Black Cat”)进入function Cat(name){  这时候的this为Cat{}对象，并非Animal，再接执行   此时的this对象绑定为Cat{},因此是Cat对象获得了两个属性为：回到 最后才是cat.showName()","tags":["Learning Note"]}]